[{"id":"089c311222389ee62ce5169132fe0b41","title":"从零到一：你的第一堂C语言入门课","content":"\n《Code101-C语言基础》目录\n\n先导课 从零到一：你的第一堂C语言入门课\n第一课 变量和常量\n第二课 printf和scanf\n第三课 putchar和getchar\n第四课 C语言运算符\n\n\n\n\n\n\n\n\n\n\n\n\n本文所有代码均在以下环境中测试通过，运行稳定、输出正确：\n\n操作系统：Windows 11 专业版 64位\n开发工具：Dev-C++ 5.11\n\n\n第一节：C语言-开启编程世界的大门C 语言是一门古老而强大的通用编程语言。它于 1972 年由丹尼斯·里奇 (Dennis Ritchie) 在贝尔实验室创造，最初是为了开发 UNIX 操作系统。如今，尽管涌现出无数现代编程语言，C 语言依然是许多技术领域的核心，活跃在操作系统、嵌入式设备、高性能计算、编译器、数据库等底层开发中，是名副其实的“数字世界的基石”。\n1. 为什么 C 语言是初学者的绝佳选择？对于编程新手而言，学习 C 语言将为你带来无与伦比的优势：\n\n打下坚实的编程基础：C 语言是许多现代语言（如 C++、Java、Go）的“祖师爷”。掌握了它的核心语法和编程思想，再学习其他语言会事半功倍。\n深入理解计算机工作原理：C 语言让你能直接与内存对话，这有助于你理解程序在底层是如何运行的，建立起清晰的“计算机思维模型”。\n培养严谨的编码习惯：由于需要手动管理内存等资源，C 语言会促使你养成严谨、高效的编码习惯，这对长远的职业发展至关重要。\n解锁广阔的技术领域：学好 C 语言，就等于拿到了进入数据结构、算法、操作系统、嵌入式开发等高阶技术领域的“入场券”。\n\n2. C 语言的核心特点\n结构化语言：采用模块化的设计，代码层次清晰，易于理解和维护。\n极致的高效性：代码会被编译成贴近硬件的机器码，运行速度极快，资源消耗少，是追求性能的“不二之选”。\n强大的可移植性：遵循 ANSI&#x2F;ISO 标准的 C 代码，几乎无需修改就能在不同的操作系统和硬件平台上编译运行。\n简洁且灵活：语法规则不多，但通过指针等特性赋予了程序员极高的操作自由度。\n\n3. 学习 C 语言需要什么？别担心，C 语言非常适合零基础入门。你只需要：\n\n一台电脑：并掌握基本的开关机、打字和文件操作。\n一颗好奇且坚韧的心：乐于动手实践，不畏惧 bug 和报错，享受解决问题的过程。\n\n4. 你的第一个 C 程序：Hello, World!让我们用一个经典的例子来感受 C 语言的魅力。\n123456#include &lt;stdio.h&gt;int main() &#123;    printf(&quot;Hello, World!\\n&quot;);    return 0;&#125;\n\n这个简单的程序展示了 C 代码的基本结构。看不懂别担心，我们很快就会逐一揭开它们的神秘面纱。准备好进入精彩的编程世界了吗？\n\n第二节：搭建开发环境与你的第一个程序在上一节，我们了解了 C 语言。现在，理论学习告一段落，让我们立刻进入激动人心的实践环节！本节将手把手地指导你搭建 C 语言开发环境，并成功编写、运行你的第一个程序。\n1. 准备你的“兵器库”：安装 Dev-C++要让计算机听懂我们用 C 语言下达的指令，需要一个专门的“翻译官”——编译器 (Compiler)。同时，我们还需要一个地方来编写代码，这就是代码编辑器 (Code Editor)。\n为了方便初学者，我们通常使用集成开发环境 (IDE, Integrated Development Environment)，它将编辑器、编译器以及其他实用工具（如调试器）打包在一起，让我们能专注于编程本身。\n\n\n\n\n\n\n\n\n\n【本教程测试环境说明】\n为了保证学习过程的顺畅，建议您也安装和使用 Dev-C++（点击下载）。\n2. 载入史册的第一个程序：”Hello, World!”安装好 Dev-C++ 后，让我们启动它，通过编写史上最著名的程序 “Hello, World!” 来揭开 C 语言的神秘面纱。\n操作步骤：\n\n打开 Dev-C++。\n点击菜单栏的 文件(F) -&gt; 新建(N) -&gt; 源代码(S)，或者直接使用快捷键 Ctrl + N。\n在新打开的编辑区中，完整地输入以下代码：\n\n12345678#include &lt;stdio.h&gt;int main() &#123;    // 我们的第一个C程序，向世界问好！    printf(&quot;Hello, World!\\n&quot;);        return 0;&#125;\n\n3. 逐行解密：”Hello, World!” 的内在逻辑这段代码虽然简短，却包含了 C 程序的基本结构。让我们把它拆开，看看每一部分都在做什么。对于以下内容不理解也不要紧，后续我们会逐步系统学习。\n\n#include &lt;stdio.h&gt;\n\n这是一个预处理指令。它的作用是在编译之前，把 C 语言标准库中的 stdio.h 文件“包含”进来。stdio 是“标准输入输出 (Standard Input&#x2F;Output)”的缩写，这个文件里包含了我们后面要用的 printf 函数的声明。\n\n\nint main()\n\nmain 函数是主函数，是整个 C 程序的唯一入口。无论你的程序多么复杂，代码总是从 main 函数的第一行开始执行。\nint 表示 main 函数执行结束后，会返回一个整数值。\n() 表明 main 是一个函数。\n\n\n&#123; ... &#125;\n\n这对花括号定义了 main 函数的函数体。所有属于 main 函数的代码都必须写在这对大括号内部。\n\n\n// 我们的第一个C程序...\n\n这是注释。以 // 开头的单行注释或者用 /* ... */ 包围的多行注释，是写给程序员看的笔记，用于解释代码。编译器在编译时会自动忽略它们。\n\n\nprintf(&quot;Hello, World!\\n&quot;);\n\n这是程序的核心执行语句。\nprintf 是一个定义在 stdio.h 中的库函数，功能是向屏幕（控制台）输出指定的文本。\n&quot;Hello, World!\\n&quot; 是一个字符串，是我们要打印的具体内容。\n\\n 是一个转义字符，意思是换行。它告诉电脑，在打印完 “Hello, World!” 之后，把光标移动到下一行的开头。\nC 语言中，大多数语句都必须以英文分号 ; 结尾，它代表一个语句的结束。初学者最常犯的错误就是忘记写分号！\n\n\nreturn 0;\n\n这条语句用于结束 main 函数，并向操作系统返回一个值。\n返回 0 是一个普遍的约定，代表程序已经正常运行并成功退出。如果返回其他非零值，通常表示程序在运行中遇到了错误。\n\n\n\n4. 编译与运行：见证奇迹的时刻代码写好后，我们需要让 Dev-C++ 把它变成可执行的程序。\n\n保存文件：点击菜单栏 文件(F) -&gt; 保存(S) (快捷键 Ctrl + S)。在弹出的窗口中，将文件名命名为 hello.c，并选择一个你找得到的位置保存它。（注意，后缀名 .c 表示这是一个 C 语言源文件）。\n\n编译并运行：这是最关键的一步！点击菜单栏 运行(E) -&gt; 编译并运行(R)，或者直接按下键盘上的 F11 键。\n\n\nDev-C++ 会自动完成“编译”和“运行”两个动作。如果代码没有错误，一个黑色的命令行窗口将会弹出，显示如下内容：\n123Hello, World!--------------------------------\n\n恭喜你！ 你已经成功地搭建了开发环境，并亲手让计算机向世界发出了问候。你已经正式迈出了成为一名程序员的第一步。\n\n\n\n\n\n\n\n\n\n我们致力于提供系统、准确且充满乐趣的 C 语言入门教程。在学习的旅程中，遇到任何问题都欢迎您在评论区留言讨论，让我们共同进步！\n","slug":"Code101/000从零到一：你的第一堂C语言入门课","date":"2025-09-01T00:00:00.000Z","categories_index":"Code101","tags_index":"c/cpp","author_index":"Random"},{"id":"5218050a0cad171f58cef1b0ffd5e306","title":"2025暑假分享","content":"本文总结2025年暑假每日分享，点击下方表格中的链接可快速跳转至对应位置。\n此处为按类型总结，如需按时间顺序请访问 Github\n\n\n\n日期\n分类\n题目名称\n题目链接\n\n\n\n0713\n双指针基础\n盛最多水的容器\n\n\n\n0714\n双指针基础\n删除有序数组中的重复项 II\n\n\n\n0715\n双指针基础\n反转字符串中的单词\n\n\n\n0716\n双指针提升\n接雨水\n\n\n\n0717\n双指针提升\n等差三元组的数目\n\n\n\n0722\n查找算法\n在排序数组中查找元素的第一个和最后一个位置\n\n\n\n0723\n查找算法\n寻找比目标字母大的最小字母\n\n\n\n0702\n查找算法\n数组搜索\n\n\n\n0727\n选择算法\n数组中的第K个最大元素（快速选择）\n\n\n\n0728\n选择算法\n数组中的第K个最大元素（堆选择法）\n\n\n\n0718\n排序算法\n排序数组（快速排序）\n\n\n\n0724\n排序算法\n排序数组（归并排序）\n\n\n\n0725\n排序算法\n排序数组（堆排序）\n\n\n\n0726\n排序算法\n排序数组（基数排序）\n\n\n\n0719\n链表基础\n合并两个有序链表\n\n\n\n0720\n链表基础\n两数相加\n\n\n\n0721\n链表基础\n分隔链表\n\n\n\n0701\n模拟\n小码哥幸运日\n\n\n\n0703\n模拟\n小码哥的艰难选择\n\n\n\n0706\n模拟&#x2F;字符串\n科学记数法\n\n\n\n0707\n模拟\n小码哥搭建花圃\n\n\n\n0709\n模拟&#x2F;贪心\n小码哥玩游戏\n\n\n\n0704\n字符串处理\n小码哥的英语\n\n\n\n0708\n贪心策略\n大促销\n\n\n\n0710\n数学\n奇怪的数\n\n\n\n0711\n数学\n快速计算\n\n\n\n0712\n数学\n因数\n\n\n\n0705\n数学\n最小公倍数\n\n\n\n0728\n位运算\n只出现一次的数字\n\n\n\n0729\n位运算\n只出现一次的数字 II\n\n\n\n0730\n位运算\n只出现一次的数字 III\n\n\n\n0731\n位运算\n丢失的数字\n\n\n\n","slug":"2025暑假分享","date":"2025-08-31T10:00:00.000Z","categories_index":"","tags_index":"","author_index":"Random"},{"id":"eaf82bf61a3a17e8e76f1b3dbfe40758","title":"变量和常量","content":"\n《Code101-C语言基础》目录\n\n先导课 从零到一：你的第一堂C语言入门课\n第一课 变量和常量\n第二课 printf和scanf\n第三课 putchar和getchar\n第四课 C语言运算符\n\n\n\n常量什么是常量?\n“量”表示数据。常量，则表示一些固定的数据，也就是不能改变的数据\n就好比现实生活中生男生女一样, 生下来是男孩永远都是男孩, 生下来是女孩就永远都是女孩, 所以性别就是现实生活中常量的一种体现\n\n\n常量的类型\n整型常量\n\n十进制整数。例如:666,-120, 0\n八进制整数,八进制形式的常量都以0开头。例如:0123,也就是十进制的83;-011,也就是十进 制的-9\n十六进制整数,十六进制的常量都是以0x开头。例如:0x123,也就是十进制的291\n二进制整数,逢二进一 0b开头。例如: 0b0010,也就是十进制的2\n\n\n实型常量\n\n小数形式\n单精度小数:以字母f或字母F结尾。例如:0.0f、1.01f\n双精度小数:十进制小数形式。例如:3.14、 6.66\n默认就是双精度\n可以没有整数位只有小数位。例如: .3、 .6f\n指数形式\n以幂的形式表示, 以字母e或字母E后跟一个10为底的幂数\n上过初中的都应该知道科学计数法吧,指数形式的常量就是科学计数法的另一种表 示,比如123000,用科学计数法表示为1.23×10的5次方\n用C语言表示就是1.23e5或1.23E5\n字母e或字母E后面的指数必须为整数\n字母e或字母E前后必须要有数字\n字母e或字母E前后不能有空格\n\n\n字符常量\n\n字符型常量都是用’’(单引号)括起来的。例如:’a’、’b’、’c’\n字符常量的单引号中只能有一个字符\n特殊情况: 如果是转义字符,单引号中可以有两个字符。例如:’\\n’、’\\t’\n\n\n字符串常量\n\n字符型常量都是用””(双引号)括起来的。例如:”a”、”abc”、”lnj”\n系统会自动在字符串常量的末尾加一个字符’\\0’作为字符串结束标志\n\n\n自定义常量\n\n后期讲解内容, 此处先不用了解\n\n\n常量类型练习\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n123\n1.1F\n1.1\n.3\n‘a’\n“a”\n“河南”\n\n\n\n变量什么是变量?\n“量”表示数据。变量，则表示一些不固定的数据，也就是可以改变的数据\n就好比现实生活中人的身高、体重一样, 随着年龄的增长会不断发生改变, 所以身高、体重就是现实生活中变量的一种体现\n就好比现实生活中超市的储物格一样, 同一个格子在不同时期不同人使用,格子中存储的物品是可以变化的。\n\n\n如何定义变量\n格式1: 变量类型 变量名称 ;\n为什么要定义变量?\n任何变量在使用之前，必须先进行定义, 只有定义了变量才会分配存储空间, 才有空间存储数据\n为什么要限定类型?\n用来约束变量所存放数据的类型。一旦给变量指明了类型，那么这个变量就只能存储这种类型的数据\n内存空间极其有限,不同类型的变量占用不同大小的存储空间\n为什么要指定变量名称?\n存储数据的空间对于我们没有任何意义, 我们需要的是空间中存储的值\n只有有了名称, 我们才能获取到空间中的值\n\n\n\n123int a;float b;char ch;\n\n\n格式2:变量类型 变量名称,变量名称;\n连续定义, 多个变量之间用逗号(,)号隔开\n\n\n\n1int a,b,c;\n\n\n变量名的命名的规范\n变量名属于标识符,所以必须严格遵守标识符的命名原则\n\n\n\n\n如何使用变量？\n可以利用&#x3D;号往变量里面存储数据\n在C语言中,利用&#x3D;号往变量里面存储数据, 我们称之为给变量赋值\n\n\n\n12int value;value = 998; // 赋值\n\n\n注意:\n这里的&#x3D;号，并不是数学中的“相等”，而是C语言中的赋值运算符，作用是将右边的整型常量998赋值给左边的整型变量value\n赋值的时候,&#x3D; 号的左侧必须是变量 (10&#x3D;b,错误)\n为了方便阅读代码, 习惯在 &#x3D; 的两侧 各加上一个 空格\n\n\n\n\n变量的初始化\nC语言中, 变量的第一次赋值，我们称为“初始化”\n初始化的两种形式\n先定义,后初始化\nint value;  value = 998; // 初始化\n定义时同时初始化\nint a = 10;  int b = 4, c = 2;\n其它表现形式(不推荐)\n\n\n\n123int a, b = 10; //部分初始化int c, d, e;c = d = e =0;\n\n\n不初始化里面存储什么?\n随机数\n上次程序分配的存储空间,存数一些 内容,“垃圾”\n系统正在用的一些数据\n\n\n\n\n如何修改变量值?\n多次赋值即可\n每次赋值都会覆盖原来的值\n\n\n\n12int i = 10;i = 20; // 修改变量的值\n\n\n变量之间的值传递\n可以将一个变量存储的值赋值给另一个变量\n\n12int a = 10;int b = a; // 相当于把a中存储的10拷贝了一份给b\n\n\n如何查看变量的值?\n使用printf输出一个或多个变量的值\n\n12int a = 10, c = 11;printf(&quot;a=%d, c=%d&quot;, a, c);\n\n\n输出其它类型变量的值\n\n123double height = 1.75;char blood = &#x27;A&#x27;;printf(&quot;height=%.2f, 血型是%c&quot;, height,  blood);\n\n\n变量的作用域\nC语言中所有变量都有自己的作用域\n变量定义的位置不同,其作用域也不同\n按照作用域的范围可分为两种, 即局部变量和全局变量\n\n\n\n局部变量\n局部变量也称为内部变量\n局部变量是在代码块内定义的, 其作用域仅限于代码块内, 离开该代码块后无法使用\n\n\n\n1234int main()&#123;    int i = 998; // 作用域开始    return 0;// 作用域结束&#125;\n\n1234567int main()&#123;    &#123;        int i = 998; // 作用域开始    &#125;// 作用域结束    printf(&quot;i = %d\\n&quot;, i); // 不能使用    return 0;&#125;\n\n123456789int main()&#123;    &#123;        &#123;            int i = 998;// 作用域开始        &#125;// 作用域结束        printf(&quot;i = %d\\n&quot;, i); // 不能使用    &#125;    return 0;&#125;\n\n\n\n全局变量\n全局变量也称为外部变量,它是在代码块外部定义的变量\n\n\n\n123456789int i = 666;int main()&#123;    printf(&quot;i = %d\\n&quot;, i); // 可以使用    return 0;&#125;// 作用域结束int call()&#123;    printf(&quot;i = %d\\n&quot;, i); // 可以使用    return 0;&#125;\n\n\n\n注意点:\n同一作用域范围内不能有相同名称的变量\n\n\n\n12345int main()&#123;    int i = 998; // 作用域开始    int i = 666; // 报错, 重复定义    return 0;&#125;// 作用域结束\n\n12345int i = 666; int i = 998; // 报错, 重复定义int main()&#123;    return 0;&#125;\n\n\n不同作用域范围内可以有相同名称的变量\n\n12345int i = 666; int main()&#123;    int i = 998; // 不会报错    return 0;&#125;\n\n12345678int main()&#123;    int i = 998; // 不会报错    return 0;&#125;int call()&#123;    int i = 666;  // 不会报错    return 0;&#125;\n","slug":"Code101/001变量和常量","date":"2025-07-27T16:00:00.000Z","categories_index":"Code101","tags_index":"c/cpp","author_index":"Random"},{"id":"0a2db89b12c09c517b822613a7e4e3dd","title":"putchar和getchar","content":"\n《Code101-C语言基础》目录\n\n先导课 从零到一：你的第一堂C语言入门课\n第一课 变量和常量\n第二课 printf和scanf\n第三课 putchar和getchar\n第四课 C语言运算符\n\n\n\nputchar和getchar\nputchar: 向屏幕输出一个字符\n\n12345#include &lt;stdio.h&gt;int main()&#123;    char ch = &#x27;a&#x27;;    putchar(ch); // 输出a&#125;\n\n\ngetchar: 从键盘获得一个字符\n\n123456#include &lt;stdio.h&gt;int main()&#123;    char ch;    ch = getchar();// 获取一个字符    printf(&quot;ch = %c\\n&quot;, ch);&#125;\n\n","slug":"Code101/003putchar和getchar","date":"2025-07-27T16:00:00.000Z","categories_index":"Code101","tags_index":"c/cpp","author_index":"Random"},{"id":"49e2daee4c328ade8673d6b073a536ac","title":"printf和scanf","content":"\n《Code101-C语言基础》目录\n\n先导课 从零到一：你的第一堂C语言入门课\n第一课 变量和常量\n第二课 printf和scanf\n第三课 putchar和getchar\n第四课 C语言运算符\n\n\n\nprintf函数\nprintf函数称之为格式输出函数,方法名称的最后一个字母f表示format。其功能是按照用户指定的格式,把指定的数据输出到屏幕上\nprintf函数的调用格式为:\nprintf(&quot;格式控制字符串&quot;,输出项列表 );\n例如:printf(&quot;a = %d, b = %d&quot;,a, b);\n非格式字符串原样输出, 格式控制字符串会被输出项列表中的数据替换\n注意: 格式控制字符串和输出项在数量和类型上必须一一对应\n\n\n\n\n\n格式控制字符串\n形式:  %[标志][输出宽度][.精度][长度]类型\n\n\n\n\n\n类型\n格式: printf(&quot;a = %类型&quot;, a);\n类型字符串用以表示输出数据的类型, 其格式符和意义如下所示\n\n\n\n\n\n\n类型\n含义\n\n\n\nd\n有符号10进制整型\n\n\ni\n有符号10进制整型\n\n\nu\n无符号10进制整型\n\n\no\n无符号8进制整型\n\n\nx\n无符号16进制整型\n\n\nX\n无符号16进制整型\n\n\nf\n单、双精度浮点数(默认保留6位小数)\n\n\ne &#x2F; E\n以指数形式输出单、双精度浮点数\n\n\ng &#x2F; G\n以最短输出宽度,输出单、双精度浮点数\n\n\nc\n字符\n\n\ns\n字符串\n\n\np\n地址\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    int b = -10;    float c = 6.6f;    double d = 3.1415926;    double e = 10.10;    char f = &#x27;a&#x27;;    // 有符号整数(可以输出负数)    printf(&quot;a = %d\\n&quot;, a); // 10    printf(&quot;a = %i\\n&quot;, a); // 10    // 无符号整数(不可以输出负数)    printf(&quot;a = %u\\n&quot;, a); // 10    printf(&quot;b = %u\\n&quot;, b); // 429496786    // 无符号八进制整数(不可以输出负数)    printf(&quot;a = %o\\n&quot;, a); // 12    printf(&quot;b = %o\\n&quot;, b); // 37777777766    // 无符号十六进制整数(不可以输出负数)    printf(&quot;a = %x\\n&quot;, a); // a    printf(&quot;b = %x\\n&quot;, b); // fffffff6    // 无符号十六进制整数(不可以输出负数)    printf(&quot;a = %X\\n&quot;, a); // A    printf(&quot;b = %X\\n&quot;, b); // FFFFFFF6    // 单、双精度浮点数(默认保留6位小数)    printf(&quot;c = %f\\n&quot;, c); // 6.600000    printf(&quot;d = %lf\\n&quot;, d); // 3.141593    // 以指数形式输出单、双精度浮点数    printf(&quot;e = %e\\n&quot;, e); // 1.010000e+001    printf(&quot;e = %E\\n&quot;, e); // 1.010000E+001        // 以最短输出宽度,输出单、双精度浮点数    printf(&quot;e = %g\\n&quot;, e); // 10.1    printf(&quot;e = %G\\n&quot;, e); // 10.1        // 输出字符    printf(&quot;f = %c\\n&quot;, f); // a&#125;\n\n\n\n宽度\n格式: printf(&quot;a = %[宽度]类型&quot;, a);\n用十进制整数来指定输出的宽度, 如果实际位数多于指定宽度,则按照实际位数输出, 如果实际位数少于指定宽度则以空格补位\n\n\n\n1234567891011#include &lt;stdio.h&gt;int main()&#123;    // 实际位数小于指定宽度    int a = 1;    printf(&quot;a =|%d|\\n&quot;, a); // |1|    printf(&quot;a =|%5d|\\n&quot;, a); // |    1|    // 实际位数大于指定宽度    int b = 1234567;    printf(&quot;b =|%d|\\n&quot;, b); // |1234567|    printf(&quot;b =|%5d|\\n&quot;, b); // |1234567|&#125;\n\n\n\n标志\n格式: printf(&quot;a = %[标志][宽度]类型&quot;, a);\n\n\n\n\n\n\n标志\n含义\n\n\n\n-\n左对齐, 默认右对齐\n\n\n+\n当输出值为正数时,在输出值前面加上一个+号, 默认不显示\n\n\n0\n右对齐时, 用0填充宽度.(默认用空格填充)\n\n\n空格\n输出值为正数时,在输出值前面加上空格, 为负数时加上负号\n\n\n#\n对c、s、d、u类型无影响\n\n\n#\n对o类型, 在输出时加前缀o\n\n\n#\n对x类型,在输出时加前缀0x\n\n\n1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main()&#123;    int a = 1;    int b = -1;    // -号标志    printf(&quot;a =|%d|\\n&quot;, a); // |1|    printf(&quot;a =|%5d|\\n&quot;, a); // |    1|    printf(&quot;a =|%-5d|\\n&quot;, a);// |1    |    // +号标志    printf(&quot;a =|%d|\\n&quot;, a); // |1|    printf(&quot;a =|%+d|\\n&quot;, a);// |+1|    printf(&quot;b =|%d|\\n&quot;, b); // |-1|    printf(&quot;b =|%+d|\\n&quot;, b);// |-1|    // 0标志    printf(&quot;a =|%5d|\\n&quot;, a); // |    1|    printf(&quot;a =|%05d|\\n&quot;, a); // |00001|    // 空格标志    printf(&quot;a =|% d|\\n&quot;, a); // | 1|    printf(&quot;b =|% d|\\n&quot;, b); // |-1|    // #号    int c = 10;    printf(&quot;c = %o\\n&quot;, c); // 12    printf(&quot;c = %#o\\n&quot;, c); // 012    printf(&quot;c = %x\\n&quot;, c); // a    printf(&quot;c = %#x\\n&quot;, c); // 0xa&#125;\n\n\n\n精度\n格式: printf(&quot;a = %[精度]类型&quot;, a); \n精度格式符以”.”开头, 后面跟上十进制整数, 用于指定需要输出多少位小数, 如果输出位数大于指定的精度, 则删除超出的部分\n\n\n\n12345#include &lt;stdio.h&gt;int main()&#123;    double a = 3.1415926;    printf(&quot;a = %.2f\\n&quot;, a); // 3.14&#125;\n\n\n动态指定保留小数位数\n格式: printf(&quot;a = %.*f&quot;, a);\n\n\n\n12345#include &lt;stdio.h&gt;int main()&#123;    double a = 3.1415926;    printf(&quot;a = %.*f&quot;, 2, a); // 3.14&#125;\n\n\n实型(浮点类型)有效位数问题\n对于单精度数,使用%f格式符输出时,仅前6~7位是有效数字\n对于双精度数,使用%lf格式符输出时,前15~16位是有效数字\n有效位数和精度(保留多少位)不同, 有效位数是指从第一个非零数字开始,误差不超过本数位半个单位的、精确可信的数位\n有效位数包含小数点前的非零数位\n\n\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    //        1234.567871093750000    float a = 1234.567890123456789;    //         1234.567890123456900    double b = 1234.567890123456789;    printf(&quot;a = %.15f\\n&quot;, a); // 前8位数字是准确的, 后面的都不准确    printf(&quot;b = %.15f\\n&quot;, b); // 前16位数字是准确的, 后面的都不准确&#125;\n\n\n\n长度\n格式: printf(&quot;a = %[长度]类型&quot;, a);\n\n\n\n\n\n\n长度\n修饰类型\n含义\n\n\n\nhh\nd、i、o、u、x\n输出char\n\n\nh\nd、i、o、u、x\n输出 short int\n\n\nl\nd、i、o、u、x\n输出 long int\n\n\nll\nd、i、o、u、x\n输出 long long int\n\n\n12345678910111213#include &lt;stdio.h&gt;int main()&#123;    char a = &#x27;a&#x27;;    short int b = 123;    int  c = 123;    long int d = 123;    long long int e = 123;    printf(&quot;a = %hhd\\n&quot;, a); // 97    printf(&quot;b = %hd\\n&quot;, b); // 123    printf(&quot;c = %d\\n&quot;, c); // 123    printf(&quot;d = %ld\\n&quot;, d); // 123    printf(&quot;e = %lld\\n&quot;, e); // 123&#125;\n\n\n转义字符\n格式: printf(&quot;%f%%&quot;, 3.1415);\n%号在格式控制字符串中有特殊含义, 所以想输出%必须添加一个转移字符\n\n\n\n1234#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;%f%%&quot;, 3.1415); // 输出结果3.1415%&#125;\n\n\nScanf函数\nscanf函数用于接收键盘输入的内容, 是一个阻塞式函数,程序会停在scanf函数出现的地方, 直到接收到数据才会执行后面的代码\nprintf函数的调用格式为:\n\n\nscanf(&quot;格式控制字符串&quot;, 地址列表);\n例如: scanf(&quot;%d&quot;, &amp;num);\n\n\n\n基本用法\n\n\n地址列表项中只能传入变量地址, 变量地址可以通过&amp;符号+变量名称的形式获取\n\n123456#include &lt;stdio.h&gt;int main()&#123;    int number;    scanf(&quot;%d&quot;, &amp;number); // 接收一个整数    printf(&quot;number = %d\\n&quot;, number); &#125;\n\n\n接收非字符和字符串类型时, 空格、Tab和回车会被忽略\n\n1234567#include &lt;stdio.h&gt;int main()&#123;    float num;    // 例如:输入 Tab 空格 回车 回车 Tab 空格 3.14 , 得到的结果还是3.14    scanf(&quot;%f&quot;, &amp;num);    printf(&quot;num = %f\\n&quot;, num);&#125;\n\n\n非格式字符串原样输入, 格式控制字符串会赋值给地址项列表项中的变量\n\n\n不推荐这种写法\n\n1234567#include &lt;stdio.h&gt;int main()&#123;    int number;    // 用户必须输入number = 数字  , 否则会得到一个意外的值    scanf(&quot;number = %d&quot;, &amp;number);    printf(&quot;number = %d\\n&quot;, number);&#125;\n\n\n接收多条数据\n\n\n格式控制字符串和地址列表项在数量和类型上必须一一对应\n非字符和字符串情况下如果没有指定多条数据的分隔符, 可以使用空格或者回车作为分隔符(不推荐这种写法)\n非字符和字符串情况下建议明确指定多条数据之间分隔符\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int number;    scanf(&quot;%d&quot;, &amp;number);    printf(&quot;number = %d\\n&quot;, number);    int value;    scanf(&quot;%d&quot;, &amp;value);    printf(&quot;value = %d\\n&quot;, value);&#125;\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int number;    int value;    // 可以输入 数字 空格 数字, 或者 数字 回车 数字    scanf(&quot;%d%d&quot;, &amp;number, &amp;value);    printf(&quot;number = %d\\n&quot;, number);    printf(&quot;value = %d\\n&quot;, value);&#125;\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int number;    int value;    // 输入 数字,数字 即可    scanf(&quot;%d,%d&quot;, &amp;number, &amp;value);    printf(&quot;number = %d\\n&quot;, number);    printf(&quot;value = %d\\n&quot;, value);&#125;\n\n\n\\n是scanf函数的结束符号, 所以格式化字符串中不能出现\\n\n\n1234567#include &lt;stdio.h&gt;int main()&#123;    int number;    // 输入完毕之后按下回车无法结束输入    scanf(&quot;%d\\n&quot;, &amp;number);    printf(&quot;number = %d\\n&quot;, number);&#125;\n","slug":"Code101/002printf和scanf","date":"2025-07-27T16:00:00.000Z","categories_index":"Code101","tags_index":"c/cpp","author_index":"Random"},{"id":"14f178cef56d02d5620710b2025709d0","title":"C语言运算符","content":"\n《Code101-C语言基础》目录\n\n先导课 从零到一：你的第一堂C语言入门课\n第一课 变量和常量\n第二课 printf和scanf\n第三课 putchar和getchar\n第四课 C语言运算符\n\n\n\n运算符基本概念\n和数学中的运算符一样, C语言中的运算符是告诉程序执行特定算术或逻辑操作的符号\n\n例如告诉程序, 某两个数相加, 相减,相乘等\n\n\n什么是表达式\n\n表达式就是利用运算符链接在一起的有意义,有结果的语句;\n例如: a + b; 就是一个算数表达式, 它的意义是将两个数相加, 两个数相加的结果就是表达式的结果\n注意: 表达式一定要有结果\n\n\n\n\n运算符分类\n按照功能划分:\n算术运算符\n赋值运算符\n关系运算符\n逻辑运算符\n位运算符\n\n\n按照参与运算的操作数个数划分:\n单目运算\n只有一个操作数 如 : i++;\n\n\n双目运算\n有两个操作数 如 : a + b;\n\n\n三目运算\nC语言中唯一的一个,也称为问号表达式 如:  a&gt;b ? 1 : 0;\n\n\n\n\n\n\n运算符的优先级和结合性\n早在小学的数学课本中,我们就学习过”从左往右,先乘除后加减,有括号的先算括号里面的”, 这句话就蕴含了优先级和结合性的问题\nC语言中,运算符的运算优先级共分为15 级。1 级最高,15 级最低\n\n\n在C语言表达式中,不同优先级的运算符, 运算次序按照由高到低执行\n\n在C语言表达式中,相同优先级的运算符, 运算次序按照结合性规定的方向执行\n\n\n\n\n优先级\n运算符\n说明\n结合性\n\n\n\n1\n() [] -&gt; .\n括号、下标、结构体成员访问\n从左到右\n\n\n2\n++ – ~ ! - + * &amp; sizeof (类型)\n单目运算符、类型转换\n从右到左\n\n\n3\n* &#x2F; %\n乘法、除法、取余\n从左到右\n\n\n4\n+ -\n加法、减法\n从左到右\n\n\n5\n&lt;&lt; &gt;&gt;\n位移\n从左到右\n\n\n6\n&lt; &lt;&#x3D; &gt; &gt;&#x3D;\n大小比较\n从左到右\n\n\n7\n&#x3D;&#x3D; !&#x3D;\n等于、不等于\n从左到右\n\n\n8\n&amp;\n位与\n从左到右\n\n\n9\n^\n位异或\n从左到右\n\n\n10\n|\n位或\n从左到右\n\n\n11\n&amp;&amp;\n逻辑与\n从左到右\n\n\n12\n||\n逻辑或\n从左到右\n\n\n13\n?:\n条件运算符（三目）\n从右到左\n\n\n14\n&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &amp;&#x3D; ^&#x3D;\n&#x3D;\n赋值及复合赋值运算符\n\n\n15\n，\n逗号运算符\n从左到右\n\n\n\n\n\n算数运算符\n\n\n优先级\n名称\n符号\n说明\n\n\n\n3\n乘法运算符\n*\n双目运算符,具有左结合性\n\n\n3\n除法运算符\n&#x2F;\n双目运算符,具有左结合性\n\n\n3\n求余运算符 (模运算符)\n%\n双目运算符,具有左结合性\n\n\n4\n加法运算符\n+\n双目运算符,具有左结合性\n\n\n4\n减法运算符\n-\n双目运算符,具有左结合性\n\n\n\n注意事项\n如果参与运算的两个操作数皆为整数, 那么结果也为整数\n如果参与运算的两个操作数其中一个是浮点数, 那么结果一定是浮点数\n求余运算符, 本质上就是数学的商和余”中的余数\n求余运算符, 参与运算的两个操作数必须都是整数, 不能包含浮点数\n求余运算符, 被除数小于除数, 那么结果就是被除数\n求余运算符, 运算结果的正负性取决于被除数,跟除数无关, 被除数是正数结果就是正数,被除数是负数结果就是负数\n求余运算符, 被除数为0, 结果为0\n求余运算符, 除数为0, 没有意义(不要这样写)\n\n\n\n123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    int b = 5;    // 加法    int result = a + b;    printf(&quot;%i\\n&quot;, result); // 15    // 减法    result = a - b;    printf(&quot;%i\\n&quot;, result); // 5    // 乘法    result = a * b;    printf(&quot;%i\\n&quot;, result); // 50    // 除法    result = a / b;    printf(&quot;%i\\n&quot;, result); // 2        // 算术运算符的结合性和优先级    // 结合性: 左结合性, 从左至右    int c = 50;    result = a + b + c; // 15 + c;  65;    printf(&quot;%i\\n&quot;, result);        // 优先级: * / % 大于 + -    result = a + b * c; // a + 250; 260;    printf(&quot;%i\\n&quot;, result);&#125;\n\n12345678#include &lt;stdio.h&gt;int main()&#123;    // 整数除以整数, 结果还是整数    printf(&quot;%i\\n&quot;, 10 / 3); // 3    // 参与运算的任何一个数是小数, 结果就是小数    printf(&quot;%f\\n&quot;, 10 / 3.0); // 3.333333&#125;\n\n123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123;    // 10 / 3 商等于3, 余1    int result = 10 % 3;    printf(&quot;%i\\n&quot;, result); // 1    // 左边小于右边, 那么结果就是左边    result = 2 % 10;    printf(&quot;%i\\n&quot;, result); // 2    // 被除数是正数结果就是正数,被除数是负数结果就是负数    result = 10 % 3;    printf(&quot;%i\\n&quot;, result); // 1    result = -10 % 3;    printf(&quot;%i\\n&quot;, result); // -1    result = 10 % -3;    printf(&quot;%i\\n&quot;, result); // 1&#125;\n\n\n赋值运算符\n\n\n优先级\n名称\n符号\n说明\n\n\n\n14\n赋值运算符\n&#x3D;\n双目运算符,具有右结合性\n\n\n14\n除后赋值运算符\n&#x2F;&#x3D;\n双目运算符,具有右结合性\n\n\n14\n乘后赋值运算符 (模运算符)\n*&#x3D;\n双目运算符,具有右结合性\n\n\n14\n取模后赋值运算符\n%&#x3D;\n双目运算符,具有右结合性\n\n\n14\n加后赋值运算符\n+&#x3D;\n双目运算符,具有右结合性\n\n\n14\n减后赋值运算符\n-&#x3D;\n双目运算符,具有右结合性\n\n\n\n简单赋值运算符\n\n1234567#include &lt;stdio.h&gt;int main()&#123;    // 简单的赋值运算符 =    // 会将=右边的值赋值给左边    int a = 10;    printf(&quot;a = %i\\n&quot;, a); // 10&#125;\n\n\n复合赋值运算符\n\n12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123;     // 复合赋值运算符 += -= *= /= %=     // 将变量中的值取出之后进行对应的操作, 操作完毕之后再重新赋值给变量     int num1 = 10;     // num1 = num1 + 1; num1 = 10 + 1; num1 = 11;     num1 += 1;     printf(&quot;num1 = %i\\n&quot;, num1); // 11     int num2 = 10;     // num2 = num2 - 1; num2 = 10 - 1; num2 = 9;     num2 -= 1;     printf(&quot;num2 = %i\\n&quot;, num2); // 9     int num3 = 10;     // num3 = num3 * 2; num3 = 10 * 2; num3 = 20;     num3 *= 2;     printf(&quot;num3 = %i\\n&quot;, num3); // 20     int num4 = 10;     // num4 = num4 / 2; num4 = 10 / 2; num4 = 5;     num4 /= 2;     printf(&quot;num4 = %i\\n&quot;, num4); // 5     int num5 = 10;     // num5 = num5 % 3; num5 = 10 % 3; num5 = 1;     num5 %= 3;     printf(&quot;num5 = %i\\n&quot;, num5); // 1&#125;\n\n\n结合性和优先级\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int number = 10;    // 赋值运算符优先级是14, 普通运算符优先级是3和4, 所以先计算普通运算符    // 普通运算符中乘法优先级是3, 加法是4, 所以先计算乘法    // number += 1 + 25; number += 26; number = number + 26; number = 36;    number += 1 + 5 * 5;    printf(&quot;number = %i\\n&quot;, number); // 36&#125;\n\n\n自增自减运算符\n在程序设计中,经常遇到“i&#x3D;i+1”和“i&#x3D;i-1”这两种极为常用的操作。\nC语言为这种操作提供了两个更为简洁的运算符,即++和–\n\n\n\n\n优先级\n名称\n符号\n说明\n\n\n\n2\n自增运算符(在后)\ni++\n单目运算符,具有左结合性\n\n\n2\n自增运算符(在前)\n++i\n单目运算符,具有右结合性\n\n\n2\n自减运算符(在后)\ni–\n单目运算符,具有左结合性\n\n\n2\n自减运算符(在前)\n–i\n单目运算符,具有右结合性\n\n\n\n\n自增\n如果只有单个变量, 无论++写在前面还是后面都会对变量做+1操作\n\n\n\n12345678#include &lt;stdio.h&gt;int main()&#123;    int number = 10;    number++;    printf(&quot;number = %i\\n&quot;, number); // 11    ++number;    printf(&quot;number = %i\\n&quot;, number); // 12&#125;\n\n\n如果出现在一个表达式中, 那么++写在前面和后面就会有所区别\n前缀表达式:++x, –x;其中x表示变量名,先完成变量的自增自减1运算,再用x的值作为表达式的值;即“先变后用”,也就是变量的值先变,再用变量的值参与运算\n后缀表达式:x++, x–;先用x的当前值作为表达式的值,再进行自增自减1运算。即“先用后变”,也就是先用变量的值参与运算,变量的值再进行自增自减变化\n\n\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int number = 10;    // ++在后, 先参与表达式运算, 再自增    // 表达式运算时为: 3 + 10;    int result = 3 + number++;    printf(&quot;result = %i\\n&quot;, result); // 13    printf(&quot;number = %i\\n&quot;, number); // 11&#125;\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int number = 10;    // ++在前, 先自增, 再参与表达式运算    // 表达式运算时为: 3 + 11;    int result = 3 + ++number;    printf(&quot;result = %i\\n&quot;, result); // 14    printf(&quot;number = %i\\n&quot;, number); // 11&#125;\n\n\n自减\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int number = 10;    // --在后, 先参与表达式运算, 再自减    // 表达式运算时为: 10 + 3;    int result = number-- + 3;    printf(&quot;result = %i\\n&quot;, result); // 13    printf(&quot;number = %i\\n&quot;, number); // 9&#125;\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int number = 10;    // --在前, 先自减, 再参与表达式运算    // 表达式运算时为: 9 + 3;    int result = --number + 3;    printf(&quot;result = %i\\n&quot;, result); // 12    printf(&quot;number = %i\\n&quot;, number); // 9&#125;\n\n\n注意点:\n自增、自减运算只能用于单个变量,只要是标准类型的变量,不管是整型、实型,还是字符型变量等,但不能用于表达式或常量\n错误用法: ++(a+b); 5++;\n\n\n企业开发中尽量让++ – 单独出现, 尽量不要和其它运算符混合在一起\n\n\n\n1234567int i = 10;int b = i++; // 不推荐或者int b = ++i; // 不推荐或者int a = 10;int b = ++a + a++;  // 不推荐\n\n\n请用如下代码替代\n\n1234567891011int i = 10;int b = i; // 推荐i++;或者;i++;int b = i; // 推荐或者int a = 10;++a;int b = a + a; // 推荐a++;\n\n\nC语言标准没有明确的规定，同一个表达式中同一个变量自增或自减后如何运算, 不同编译器得到结果也不同, 在企业开发中千万不要这样写\n\n1234567 int a = 1; // 下列代码利用Qt运行时6, 利用Xcode运行是5 // 但是无论如何, 最终a的值都是3//  在C语言中这种代码没有意义, 不用深究也不要这样写// 特点: 参与运算的是同一个变量, 参与运算时都做了自增自减操作, 并且在同一个表达式中 int b = ++a + ++a; printf(&quot;b = %i\\n&quot;, b); \n\n\nsizeof运算符\nsizeof可以用来计算一个变量或常量、数据类型所占的内存字节数\n标准格式: sizeof(常量 or 变量);\n\n\nsizeof的几种形式\nsizeof( 变量\\常量 );\nsizeof(10);\nchar c = &#39;a&#39;; sizeof(c);\n\n\nsizeof 变量\\常量;\nsizeof 10;\nchar c = &#39;a&#39;; sizeof c;\n\n\nsizeof( 数据类型);\nsizeof(float);\n如果是数据类型不能省略括号\n\n\n\n\n\n12345678910#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    double b = 3.14;    // 由于sizeof的优先级比+号高, 所以会先计算sizeof(a);    // a是int类型, 所以占4个字节得到结果4    // 然后再利用计算结果和b相加, 4 + 3.14 = 7.14    double res = sizeof a+b;    printf(&quot;res = %lf\\n&quot;, res); // 7.14&#125;\n\n\n逗号运算符\n在C语言中逗号“,”也是一种运算符,称为逗号运算符。 其功能是把多个表达式连接起来组成一个表达式,称为逗号表达式\n逗号运算符会从左至右依次取出每个表达式的值, 最后整个逗号表达式的值等于最后一个表达式的值\n格式: 表达式1，表达式2，… …，表达式n;\n\n\n例如: int result = a+1,b=3*4;\n\n12345678910#include &lt;stdio.h&gt;int main()&#123;    int a = 10, b = 20, c;    // ()优先级高于逗号运算符和赋值运算符, 所以先计算()中的内容    // c = (11, 21);    // ()中是一个逗号表达式, 结果是最后一个表达式的值, 所以计算结果为21    // 将逗号表达式的结果赋值给c, 所以c的结果是21    c = (a + 1, b + 1);    printf(&quot;c = %i\\n&quot;, c); // 21&#125;\n\n\n关系运算符\n为什么要学习关系运算符\n\n\n默认情况下，我们在程序中写的每一句正确代码都会被执行。但很多时候，我们想在某个条件成立的情况下才执行某一段代码\n这种情况的话可以使用条件语句来完成，但是学习条件语句之前，我们先来看一些更基础的知识：如何判断一个条件是否成立\n\n\n\nC语言中的真假性\n\n\n在C语言中，条件成立称为“真”，条件不成立称为“假”，因此，判断条件是否成立，就是判断条件的“真假”\n怎么判断真假呢？C语言规定，任何数值都有真假性，任何非0值都为“真”，只有0才为“假”。也就是说，108、-18、4.5、-10.5等都是“真”，0则是“假”\n\n\n\n关系运算符的运算结果只有2种：如果条件成立，结果就为1，也就是“真”；如果条件不成立，结果就为0，也就是“假”\n\n\n\n\n优先级\n名称\n符号\n说明\n\n\n\n6\n大于运算符\n&gt;\n双目运算符,具有左结合性\n\n\n6\n小于运算符\n&lt;\n双目运算符,具有左结合性\n\n\n6\n大于等于运算符\n&gt;&#x3D;\n双目运算符,具有左结合性\n\n\n6\n小于等于运算符\n&lt;&#x3D;\n双目运算符,具有左结合性\n\n\n7\n等于运算符\n&#x3D;&#x3D;\n双目运算符,具有左结合性\n\n\n7\n不等于运算符\n!&#x3D;\n双目运算符,具有左结合性\n\n\n1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123;    int result = 10 &gt; 5;    printf(&quot;result = %i\\n&quot;, result); // 1    result = 5 &lt; 10;    printf(&quot;result = %i\\n&quot;, result); // 1    result = 5 &gt; 10;    printf(&quot;result = %i\\n&quot;, result); // 0    result = 10 &gt;= 10;    printf(&quot;result = %i\\n&quot;, result); // 1    result = 10 &lt;= 10;    printf(&quot;result = %i\\n&quot;, result); // 1    result = 10 == 10;    printf(&quot;result = %i\\n&quot;, result); // 1    result = 10 != 9;    printf(&quot;result = %i\\n&quot;, result); // 1&#125;\n\n\n优先级和结合性\n\n1234567#include &lt;stdio.h&gt;int main()&#123;    // == 优先级 小于 &gt;, 所以先计算&gt;    // result = 10 == 1; result = 0;    int result = 10 == 5 &gt; 3;    printf(&quot;result = %i\\n&quot;, result); // 0&#125;\n\n12345678#include &lt;stdio.h&gt;int main()&#123;    // == 和 != 优先级一样, 所以按照结合性    // 关系运算符是左结合性, 所以从左至右计算    // result = 0 != 3; result = 1;    int result = 10 == 5 != 3;    printf(&quot;result = %i\\n&quot;, result); // 1&#125;\n\n\n练习: 计算result的结果\n\n123int result1 = 3 &gt; 4 + 7int result2 = (3&gt;4) + 7int result3 = 5 != 4 + 2 * 7 &gt; 3 == 10\n\n\n注意点:\n无论是float还是double都有精度问题, 所以一定要避免利用&#x3D;&#x3D;判断浮点数是否相等\n\n\n\n12345678910#include &lt;stdio.h&gt;int main()&#123;    float a = 0.1;    float b = a * 10 + 0.00000000001;    double c = 1.0 + + 0.00000000001;    printf(&quot;b = %f\\n&quot;, b);    printf(&quot;c = %f\\n&quot;, c);    int result = b == c;    printf(&quot;result = %i\\n&quot;, result); // 0&#125;\n\n\n逻辑运算符\n\n\n优先级\n名称\n符号\n说明\n\n\n\n2\n逻辑非运算符\n!\n单目运算符,具有右结合性\n\n\n11\n逻辑与运算符\n&amp;&amp;\n双目运算符,具有左结合性\n\n\n12\n逻辑或运算符\n||\n双目运算符,具有左结合性\n\n\n\n逻辑非\n\n\n格式: ! 条件A;\n\n运算结果: 真变假,假变真\n\n运算过程:\n\n先判断条件A是否成立，如果添加A成立, 那么结果就为0，即“假”；\n如果条件A不成立，结果就为1，即“真”\n\n\n使用注意:\n\n\n可以多次连续使用逻辑非运算符\n!!!0;相当于(!(!(!0)));最终结果为1\n\n\n\n12345678#include &lt;stdio.h&gt;int main()&#123;    // ()优先级高, 先计算()里面的内容    // 10==10为真, 所以result = !(1);    // !代表真变假, 假变真,所以结果是假0    int result = !(10 == 10);    printf(&quot;result = %i\\n&quot;, result); // 0&#125;\n\n\n\n逻辑与\n\n格式: 条件A &amp;&amp; 条件B;\n运算结果:一假则假\n运算过程:\n\n\n总是先判断”条件A”是否成立\n如果”条件A”成立，接着再判断”条件B”是否成立, 如果”条件B”也成立，结果就为1，即“真”\n如果”条件A”成立，”条件B”不成立，结果就为0，即“假”\n如果”条件A”不成立，不会再去判断”条件B”是否成立, 因为逻辑与只要一个不为真结果都不为真\n\n\n使用注意:\n\n\n“条件A”为假, “条件B”不会被执行\n\n\n\n123456789101112131415#include &lt;stdio.h&gt;int main()&#123;    //               真     &amp;&amp;    真    int result = (10 == 10) &amp;&amp; (5 != 1);    printf(&quot;result = %i\\n&quot;, result); // 1    //          假     &amp;&amp;    真    result = (10 == 9) &amp;&amp; (5 != 1);    printf(&quot;result = %i\\n&quot;, result); // 0    //          真     &amp;&amp;    假    result = (10 == 10) &amp;&amp; (5 != 5);    printf(&quot;result = %i\\n&quot;, result); // 0    //          假     &amp;&amp;    假    result = (10 == 9) &amp;&amp; (5 != 5);    printf(&quot;result = %i\\n&quot;, result); // 0&#125;\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    int b = 20;    // 逻辑与, 前面为假, 不会继续执行后面    int result = (a == 9) &amp;&amp; (++b);    printf(&quot;result = %i\\n&quot;, result); // 1    printf(&quot;b = %i\\n&quot;, b); // 20&#125;\n\n\n\n逻辑或\n\n格式: 条件A || 条件B;\n运算结果:一真则真\n运算过程:\n\n\n总是先判断”条件A”是否成立\n如果”条件A”不成立，接着再判断”条件B”是否成立, 如果”条件B”成立，结果就为1，即“真”\n如果”条件A”不成立，”条件B”也不成立成立, 结果就为0，即“假”\n如果”条件A”成立, 不会再去判断”条件B”是否成立, 因为逻辑或只要一个为真结果都为真\n\n\n使用注意:\n\n\n“条件A”为真, “条件B”不会被执行\n\n\n\n123456789101112131415#include &lt;stdio.h&gt;int main()&#123;    //               真     ||    真    int result = (10 == 10) || (5 != 1);    printf(&quot;result = %i\\n&quot;, result); // 1    //          假     ||    真    result = (10 == 9) || (5 != 1);    printf(&quot;result = %i\\n&quot;, result); // 1    //          真     ||    假    result = (10 == 10) || (5 != 5);    printf(&quot;result = %i\\n&quot;, result); // 1    //          假     ||    假    result = (10 == 9) || (5 != 5);    printf(&quot;result = %i\\n&quot;, result); // 0&#125;\n\n123456789#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    int b = 20;    // 逻辑或, 前面为真, 不会继续执行后面    int result = (a == 10) || (++b);    printf(&quot;result = %i\\n&quot;, result); // 1    printf(&quot;b = %i\\n&quot;, b); // 20&#125;\n\n\n练习: 计算result的结果\n\n1int result = 3&gt;5 || 2&lt;4 &amp;&amp; 6&lt;1;\n\n\n三目运算符\n三目运算符，它需要3个数据或表达式构成条件表达式\n格式: 表达式1？表达式2(结果A)：表达式3(结果B)\n\n\n示例: 考试及格 ? 及格 : 不及格;\n\n\n求值规则:\n\n\n如果”表达式1”为真，三目运算符的运算结果为”表达式2”的值(结果A)，否则为”表达式3”的值(结果B)\n\n12345678910111213141516示例:    int a = 10;    int b = 20;    int max = (a &gt; b) ? a : b;    printf(&quot;max = %d&quot;, max);    输出结果: 20等价于:    int a = 10;    int b = 20;    int max = 0;    if(a&gt;b)&#123;      max=a;    &#125;else &#123;       max=b;    &#125;    printf(&quot;max = %d&quot;, max);\n\n\n注意点\n\n\n条件运算符的运算优先级低于关系运算符和算术运算符,但高于赋值符\n条件运算符?和:是一个整体,不能分开使用\n\n12345678910#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    int b = 5;    // 先计算 a &gt; b    // 然后再根据计算结果判定返回a还是b    // 相当于int max= (a&gt;b) ? a : b;    int max= a&gt;b ? a : b;    printf(&quot;max = %i\\n&quot;, max); // 10&#125;\n\n12345678910111213141516#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    int b = 5;    int c = 20;    int d = 10;    // 结合性是从右至左, 所以会先计算:后面的内容    // int res = a&gt;b?a:(c&gt;d?c:d);    // int res = a&gt;b?a:(20&gt;10?20:10);    // int res = a&gt;b?a:(20);    // 然后再计算最终的结果    // int res = 10&gt;5?10:(20);    // int res = 10;    int res = a&gt;b?a:c&gt;d?c:d;    printf(&quot;res = %i\\n&quot;, res);&#125;\n\n\n类型转换\n\n\n强制类型转换(显示转换)\n自动类型转换(隐式转换)\n\n\n\n(需要转换的类型)(表达式)\n1.算数转换 2.赋值转换\n\n\n\n强制类型转换(显示转换)\n\n12// 将double转换为intint a = (int)10.5;\n\n\n算数转换\n系统会自动对占用内存较少的类型做一个“自动类型提升”的操作, 先将其转换为当前算数表达式中占用内存高的类型, 然后再参与运算\n\n\n\n123// 当前表达式用1.0占用8个字节, 2占用4个字节// 所以会先将整数类型2转换为double类型之后再计算double b = 1.0 / 2;\n\n\n赋值转换\n\n12// 赋值时左边是什么类型,就会自动将右边转换为什么类型再保存int a = 10.6;\n\n\n注意点:\n\n\n参与计算的是什么类型, 结果就是什么类型\n\n1234// 结果为0, 因为参与运算的都是整型double a = (double)(1 / 2);// 结果为0.5, 因为1被强制转换为了double类型, 2也会被自动提升为double类型double b = (double)1 / 2;\n\n\n类型转换并不会影响到原有变量的值\n\n1234567#include &lt;stdio.h&gt;int main()&#123;    double d = 3.14;    int num = (int)d;    printf(&quot;num = %i\\n&quot;, num); // 3    printf(&quot;d = %lf\\n&quot;, d); // 3.140000&#125;。\n","slug":"Code101/004C语言运算符","date":"2025-07-27T16:00:00.000Z","categories_index":"Code101","tags_index":"c/cpp","author_index":"Random"},{"id":"1ef7b5c1febefbecd2fae064a2008e72","title":"LeetCode-744寻找比目标字母大的最小字母","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode 744. Find Smallest Letter Greater Than Target\n题目描述给定一个递增排序的字符数组 letters（可能包含环绕），和一个目标字符 target，要求返回数组中大于 target 的最小字符。\n若不存在满足条件的字符，则返回 letters[0]，即“首位环绕”。\n\n解法一：二分这是一个经典的二分查找问题，目标是找出 第一个大于 target 的字符。可以直接套用「变形版 upper_bound 模板」，即：\n12345if (letters[mid] &lt;= target) &#123;    l = mid + 1;&#125; else &#123;    r = mid - 1;&#125;\n\n\n当 letters[mid] &lt;= target：说明 mid 及其左侧都不符合要求，目标在右边 → l = mid + 1\n当 letters[mid] &gt; target：mid 是一个候选答案，尝试向左搜索更小的 → r = mid - 1\n\n最后循环结束时，l 会指向第一个满足 letters[l] &gt; target 的元素。\n\n环绕处理当 target 大于等于所有字符时，l 会超出数组长度（即 l == letters.size()），这时应该返回数组开头的字符 letters[0]。\n代码中用到了：\n1letters[l % letters.size()]\n\n这个技巧巧妙地利用取模操作实现了首尾环绕处理，可以避免边界判断。\n\n代码123456789101112131415class Solution &#123;public:    char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123;        int l = 0, r = letters.size() - 1;        while (l &lt;= r) &#123;            int mid = l + ((r - l) &gt;&gt; 1);            if (letters[mid] &lt;= target) &#123;                l = mid + 1;            &#125; else &#123;                r = mid - 1;            &#125;        &#125;        return letters[l % letters.size()];    &#125;&#125;;\n\n\n举个例子输入：\n1letters = [&#x27;c&#x27;, &#x27;f&#x27;, &#x27;j&#x27;], target = &#x27;d&#x27;\n\n查找过程中：\n\nmid &#x3D; 1 → letters[1]&#x3D;’f’ &gt; ‘d’，缩小右边界 r&#x3D;0\nmid &#x3D; 0 → letters[0]&#x3D;’c’ &lt;&#x3D; ‘d’，l&#x3D;1\n循环结束，l&#x3D;1，返回 letters[1]&#x3D;’f’\n\n\n总结这题考察的是二分搜索在查找「第一个大于目标」元素时的使用方式，配合 % letters.size() 做环绕处理，逻辑清晰又简洁\n","slug":"LeetCode/LeetCode-744寻找比目标字母大的最小字母","date":"2025-07-23T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"c8e3ec39a2bdb46713f60afe507c2dde","title":"LeetCode-34在排序数组中查找元素的第一个和最后一个位置","content":"\n\n\n\n\n\n\n\n\n题目链接： LeetCode 34. Find First and Last Position of Element in Sorted Array\n题目描述给定一个按 非递减顺序 排列的整数数组 nums，以及一个整数 target，请找出 target 在数组中出现的 第一个 和 最后一个位置。\n\n如果数组中不存在目标值 target，返回 [-1, -1]。\n要求时间复杂度为 O(log n)，使用二分查找。\n\n\n解题思路本质是二分查找的两次应用：\n第一次二分查找：找出目标值 target 的左边界（第一个等于 target 的位置）。\n第二次二分查找：找出目标值 target 的右边界（最后一个等于 target 的位置）。\n\n注意事项：\n数组可能不存在 target，需单独判断。\n二分写法需根据使用的是哪种区间（闭区间、左闭右开、开区间）进行边界调整。\n\n\n解法一：左闭右闭区间 [left, right]123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public:    // 查找 target 的左边界（第一个等于 target 的位置）    int findLeft(const vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;  // 左闭右闭区间 [left, right]            int mid = left + (right - left) / 2;            if (nums[mid] &lt; target) &#123;                left = mid + 1;  // target 在右边            &#125; else &#123;                right = mid - 1; // 向左收缩（即使等于也继续左边找）            &#125;        &#125;        // 检查 left 是否越界 或 是否是 target        if (left &lt; nums.size() &amp;&amp; nums[left] == target) return left;        return -1;    &#125;    // 查找 target 的右边界（最后一个等于 target 的位置）    int findRight(const vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;  // 左闭右闭区间 [left, right]            int mid = left + (right - left) / 2;            if (nums[mid] &gt; target) &#123;                right = mid - 1; // target 在左边            &#125; else &#123;                left = mid + 1;  // 向右收缩（即使等于也继续右边找）            &#125;        &#125;        // 检查 right 是否越界 或 是否是 target        if (right &gt;= 0 &amp;&amp; nums[right] == target) return right;        return -1;    &#125;    // 主函数：返回目标值的起始和结束位置    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = findLeft(nums, target);        if (left == -1) return &#123;-1, -1&#125;;  // target 不存在        int right = findRight(nums, target);        return &#123;left, right&#125;;    &#125;&#125;;\n\n\n解法二：左闭右开区间：待更新\n解法三：开区间 ：待更新\n示例测试用例\n\n\n输入\n输出\n说明\n\n\n\nnums = [5,7,7,8,8,10] target = 8\n[3,4]\ntarget 存在，返回区间位置\n\n\nnums = [5,7,7,8,8,10] target = 6\n[-1,-1]\ntarget 不存在\n\n\nnums = [] target = 0\n[-1,-1]\n空数组\n\n\n","slug":"LeetCode/LeetCode-34在排序数组中查找元素的第一个和最后一个位置","date":"2025-07-22T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"3db473fdf9b2739246e485648c59f7e1","title":"LeetCode-86分隔链表","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode 86. Partition List\n题目描述给定一个链表 head 和一个特定值 x，请将所有小于 x 的节点排在大于或等于 x 的节点之前。\n你应该保留原始相对顺序。\n示例：12输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5\n\n\n解法一：模拟我们将链表划分为两个部分：\n\n一个链表保存 小于 x 的节点（记为 left 链表）；\n一个链表保存 大于等于 x 的节点（记为 right 链表）；\n最后将两个链表拼接起来。\n\n关键点：\n使用 leftHead 和 leftTail 维护左边链表；\n使用 rightHead 和 rightTail 维护右边链表；\n使用 head-&gt;next = nullptr 断开原链表，避免成环。\n\n\n动图理解（文字版）假设原链表为：\n12head: 1 → 4 → 3 → 2 → 5 → 2x = 3\n\n处理过程如下：\n\n遇到 1 → 放入 left 链表\n遇到 4 → 放入 right 链表\n遇到 3 → 放入 right 链表\n遇到 2 → 放入 left 链表\n遇到 5 → 放入 right 链表\n遇到 2 → 放入 left 链表\n\n最终：\n123left: 1 → 2 → 2right: 4 → 3 → 5结果: 1 → 2 → 2 → 4 → 3 → 5\n\n\n代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public:    ListNode* partition(ListNode* head, int x) &#123;        // 定义左右两个链表的头尾指针        ListNode *leftHead = nullptr, *leftTail = nullptr;        ListNode *rightHead = nullptr, *rightTail = nullptr;        while (head != nullptr) &#123;            ListNode* next = head-&gt;next;  // 保存下一个节点            head-&gt;next = nullptr;         // 当前节点断链，避免成环            if (head-&gt;val &lt; x) &#123;          // 小于 x 放左边                if (leftHead == nullptr)  // 初始化左链表                    leftHead = head;                else                    leftTail-&gt;next = head;                leftTail = head;          // 移动尾指针            &#125; else &#123;                      // 大于等于 x 放右边                if (rightHead == nullptr)                    rightHead = head;                else                    rightTail-&gt;next = head;                rightTail = head;            &#125;            head = next;  // 处理下一个节点        &#125;        // 连接左右链表        if (leftHead == nullptr) return rightHead;        leftTail-&gt;next = rightHead;        return leftHead;    &#125;&#125;;\n\n\n边界处理要点\n如果原链表为空（head 为 nullptr），函数会自动返回 nullptr。\n如果所有节点都 ≥ x，则 leftHead 为 nullptr，直接返回 rightHead。\nhead-&gt;next = nullptr; 非常关键，避免原链表中断开或形成环。\n左链表和右链表保持原始节点顺序（因为只操作 next）。\n\n\n示例\n\n\n输入\nx\n输出\n\n\n\n1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2\n3\n1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5\n\n\n2-&gt;1\n2\n1-&gt;2\n\n\n5-&gt;6-&gt;7\n4\n5-&gt;6-&gt;7\n\n\n1-&gt;2-&gt;3\n10\n1-&gt;2-&gt;3\n\n\n空链表 nullptr\n1\nnullptr\n\n\n","slug":"LeetCode/LeetCode-86分隔链表","date":"2025-07-21T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"2e0b75e87a11aa9fe9b055b9179f2839","title":"LeetCode-2两数相加","content":"\n\n\n\n\n\n\n\n\n题目链接： LeetCode 2. Add Two Numbers）\n题目描述给你两个 非空 的链表 l1 和 l2，它们表示两个 非负整数，每位数字都是逆序存储 的，每个节点只存储一位数字。\n请你将这两个数相加，并以同样形式返回一个代表和的链表。\n示例：123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807\n\n\n解法一：模拟由于两个数是以逆序存储的，所以我们可以从两个链表的头部开始逐位相加：\n\n模拟竖式加法：从低位开始相加（即从链表头开始），依次处理进位。\n每次处理一位，并创建一个新节点表示该位结果。\n若最后还有进位，则需要额外加一个新节点。\n\n\n步骤\n定义两个指针：head 为结果链表头，cur 为当前操作指针；\n定义变量 carry = 0 表示进位；\n遍历 l1 和 l2 的每一位数字：\n若某一链表已结束，则看作是 0；\n计算当前位 sum = val1 + val2 + carry；\n当前位值为 sum % 10，进位为 sum / 10；\n\n\n如果最后进位 carry &gt; 0，则加上一个新节点；\n返回结果链表头 head。\n\n\n代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode *head = nullptr, *cur = nullptr;        int carry = 0;        // 遍历 l1 和 l2 的每一位        for (int sum, val; l1 != nullptr || l2 != nullptr;             l1 = (l1 == nullptr ? nullptr : l1-&gt;next),             l2 = (l2 == nullptr ? nullptr : l2-&gt;next)) &#123;                        // 当前位和 = l1值 + l2值 + 上一位进位            sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + carry;            val = sum % 10;     // 当前位数字            carry = sum / 10;   // 进位            // 创建节点并接入链表            if (head == nullptr) &#123;                head = new ListNode(val);                cur = head;            &#125; else &#123;                cur-&gt;next = new ListNode(val);                cur = cur-&gt;next;            &#125;        &#125;        // 如果还有进位，最后加一位        if (carry == 1) &#123;            cur-&gt;next = new ListNode(1);        &#125;        return head;    &#125;&#125;;\n\n\n边界处理细节\n\n\n情况\n是否处理？\n说明\n\n\n\nl1 或 l2 为 nullptr\n✅\n使用三元运算符 (l1 ? l1-&gt;val : 0) 处理\n\n\n两链表长度不同\n✅\n遍历到最长链表结束即可\n\n\n最后一位有进位\n✅\nif (carry == 1) 添加尾部节点\n\n\n\n示例\n\n\nl1\nl2\n输出结果\n说明\n\n\n\n[2,4,3]\n[5,6,4]\n[7,0,8]\n342 + 465 &#x3D; 807\n\n\n[0]\n[0]\n[0]\n简单零值\n\n\n[9,9,9]\n[1]\n[0,0,0,1]\n999 + 1 &#x3D; 1000\n\n\n","slug":"LeetCode/LeetCode-2两数相加","date":"2025-07-20T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"ceb487e3836d4783d6609198e2dba7d6","title":"LeetCode-21合并两个有序链表","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode 21. Merge Two Sorted Lists\n题目描述给你两个 升序 链表 list1 和 list2，请将它们合并为一个新的 升序 链表，并返回新链表的头节点。\n\n解法一：迭代解题思路这道题的关键在于：两个链表已经是有序的，所以我们可以使用 双指针 + 逐步合并 的方式来构建一个新的有序链表。\n相比于常见的虚拟头节点解法，这段代码采用了原地合并 + 不额外创建节点 的策略，节省了空间。\n\n核心逻辑解析123if (list1 == nullptr || list2 == nullptr) &#123;    return list1 == nullptr ? list2 : list1;&#125;\n\n\n边界情况处理：如果有一个链表为空，直接返回另一个链表。\n\n1ListNode* head = list1-&gt;val &gt; list2-&gt;val ? list2 : list1;\n\n\n选出头结点：将两个链表中值较小的那个作为合并后链表的头。\n\n123ListNode* cur1 = head-&gt;next;ListNode* cur2 = (head == list1) ? list2 : list1;ListNode* pre = head;\n\n\n初始化指针：\ncur1 是当前主链表（较小值所在链表）后继；\ncur2 是另一个链表；\npre 记录新链表的构建位置。\n\n\n\n\n循环合并过程12345678910while (cur1 != nullptr &amp;&amp; cur2 != nullptr) &#123;    if (cur1-&gt;val &gt; cur2-&gt;val) &#123;        pre-&gt;next = cur2;        cur2 = cur2-&gt;next;    &#125; else &#123;        pre-&gt;next = cur1;        cur1 = cur1-&gt;next;    &#125;    pre = pre-&gt;next;&#125;\n\n\n每次将当前值较小的节点接到 pre 后，并移动相应指针。\n\n\n拼接剩余链表1pre-&gt;next = cur1 != nullptr ? cur1 : cur2;\n\n\n当有一个链表已经走完，直接将另一个剩下的部分接在后面。\n\n\n完整代码（C++）123456789101112131415161718192021222324252627class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        if (list1 == nullptr || list2 == nullptr) &#123;            return list1 == nullptr ? list2 : list1;        &#125;        ListNode* head = list1-&gt;val &gt; list2-&gt;val ? list2 : list1;        ListNode* cur1 = head-&gt;next;        ListNode* cur2 = (head == list1) ? list2 : list1;        ListNode* pre = head;        while (cur1 != nullptr &amp;&amp; cur2 != nullptr) &#123;            if (cur1-&gt;val &gt; cur2-&gt;val) &#123;                pre-&gt;next = cur2;                cur2 = cur2-&gt;next;            &#125; else &#123;                pre-&gt;next = cur1;                cur1 = cur1-&gt;next;            &#125;            pre = pre-&gt;next;        &#125;        pre-&gt;next = cur1 != nullptr ? cur1 : cur2;        return head;    &#125;&#125;;\n\n\n小结这段代码技巧性强，不使用虚拟头节点，而是从一开始就选定一个较小节点作为 head，在效率和空间上都表现优秀\n","slug":"LeetCode/LeetCode-21合并两个有序链表","date":"2025-07-19T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"94d081a5c7789012b1a36e6503ab4408","title":"LeetCode-912排序数组","content":"\n\n\n\n\n\n\n\n\nLeetCode - 912. 排序数组\n题目描述：给你一个整数数组 nums，请你将该数组升序排列。你必须在 不使用任何内置函数 的情况下解决问题，时间复杂度为 O(n log n)，并且空间复杂度尽可能小。\n示例 1：\n\n\n\n\n\n\n\n\n\n输入： nums &#x3D; [5,2,3,1]输出： [1,2,3,5]\n示例 2：\n\n\n\n\n\n\n\n\n\n输入： nums &#x3D; [5,1,1,2,0,0]输出： [0,0,1,1,2,5]\n\n解法一：快速排序不了解快速排序的可以先看（快速排序（点击跳转））\n这道题要求我们对一个整数数组进行升序排序，并明确限制了不能使用内置排序函数，同时要求时间复杂度为 O(n log n)，空间复杂度尽可能小。快速排序 是满足这些要求的经典算法之一，尤其适合作为本题的解法。\n算法思想我们将采用 快速排序（Quick Sort） 算法，它是一种基于 分治 思想的高效排序算法，其核心步骤如下：\n\n分区 (Partition)：从数组中选择一个元素作为“基准”（pivot）。为了避免在数组已有序或近乎有序时出现 O(n²) 的最坏情况，我们 随机选择 一个基准。然后，重新排列数组，使得所有小于基准的元素都移动到基准的左边，所有大于等于基准的元素都移动到右边。操作结束后，该基准元素就位于其最终的有序位置。\n\n递归 (Recurse)：对基准左侧和右侧的两个子数组，递归地应用快速排序。\n\n终止条件：当子数组的长度为 0 或 1 时，它天然是有序的，递归结束。\n\n\n通过这种方式，一个大问题被不断地分解成小问题来解决，最终完成整个数组的排序。\n代码实现 (C++)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;        // 初始化随机种子，以确保每次运行的随机性，避免最坏情况        srand(time(0));         quickSort(nums, 0, nums.size() - 1);        return nums;    &#125;private:    /**     * @brief 对数组 nums 的 [low, high] 区间进行快速排序     */    void quickSort(vector&lt;int&gt;&amp; nums, int low, int high) &#123;        // 终止条件：当子数组只有一个元素或为空时        if (low &gt;= high) &#123;            return;        &#125;        // 找到基准元素的正确位置        int pivotIndex = partition(nums, low, high);        // 递归地对基准左侧的子数组进行排序        quickSort(nums, low, pivotIndex - 1);        // 递归地对基准右侧的子数组进行排序        quickSort(nums, pivotIndex + 1, high);    &#125;    /**     * @brief 分区操作，并返回基准元素的最终索引     */    int partition(vector&lt;int&gt;&amp; nums, int low, int high) &#123;        // 1. 随机选择一个基准，并将其与区间的最后一个元素交换        //    这样做可以有效避免最坏情况的发生        int randomIndex = low + rand() % (high - low + 1);        swap(nums[randomIndex], nums[high]);                int pivot = nums[high]; // 将最后一个元素作为基准        int i = low; // i 指向下一个小于基准的元素应该存放的位置        // 2. 遍历数组，将小于基准的元素移动到 i 指针的左侧        for (int j = low; j &lt; high; j++) &#123;            if (nums[j] &lt; pivot) &#123;                swap(nums[i], nums[j]);                i++;            &#125;        &#125;                // 3. 将基准元素放到它的最终位置 (i)        swap(nums[i], nums[high]);                return i; // 返回基准元素的索引    &#125;&#125;;\n\n","slug":"LeetCode/LeetCode-912排序数组","date":"2025-07-18T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"dea48bae008655416810ebc549cb2ffd","title":"冒泡排序（Bubble Sort）","content":"冒泡排序（Bubble Sort）冒泡排序是一种简单直观的排序算法。它重复地遍历待排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n一、算法原理1.1 核心思想冒泡排序的核心在于重复地比较并交换相邻元素。它会遍历整个数组，每次比较相邻的两个元素，如果它们的顺序不正确（例如，前者大于后者），就将它们交换。通过这样一轮轮的遍历，每一轮都会将当前未排序部分中的最大（或最小）元素“冒泡”到其最终位置。\n1.2 详细步骤\n比较与交换：从数组的第一个元素开始，比较它与下一个元素的大小。如果顺序错误，则交换它们。\n向后移动：将比较窗口向后移动一位，继续比较下一对相邻元素，重复此过程直到数组末尾。\n完成一轮：当完成从头到尾的一轮遍历后，数组中最大的元素会被放置在最后一个位置。\n缩小范围：忽略已经排好序的最后一个元素，对前面的 n-1 个元素重复以上步骤。\n终止条件：持续这个过程，直到整个数组排序完成。\n\n1.3 示例演示以数组 [6, 4, 7, 2, 9] 为例，排序过程如下：\n\n\n\n轮次\n过程描述\n数组状态\n\n\n\n第1轮\n6&gt;4交换, 6&lt;7不换, 7&gt;2交换, 7&lt;9不换\n[4, 6, 2, 7, **9**]\n\n\n第2轮\n4&lt;6不换, 6&gt;2交换, 6&lt;7不换\n[4, 2, 6, **7**, 9]\n\n\n第3轮\n4&gt;2交换, 4&lt;6不换\n[2, 4, **6**, 7, 9]\n\n\n第4轮\n2&lt;4不换\n[**2**, 4, 6, 7, 9]\n\n\n\n二、性能与特点2.1 复杂度分析\n时间复杂度\n最佳情况：O(n) - 当数组几乎有序时，优化后的算法只需一轮遍历。\n平均情况：O(n²)\n最坏情况：O(n²) - 当数组完全逆序时。\n\n\n空间复杂度：O(1) - 属于原地排序，仅需常数级别的额外空间。\n稳定性：稳定。因为只有当前元素严格大于后一个元素时才交换，相等元素的相对顺序不会改变。\n\n2.2 优缺点\n\n\n优点\n缺点\n\n\n\n实现简单，代码易于理解\n效率低下，不适合大规模数据\n\n\n稳定性好，保留相等元素顺序\n比较和交换次数过多\n\n\n空间占用少，是原地排序算法\n性能远不如快速排序、归并排序等\n\n\n2.3 适用场景\n教学演示：作为入门级排序算法，非常适合教学。\n小规模数据：当待排序的元素数量很少时（例如 n &lt; 20），其简单性可能优于复杂算法的设置开销。\n几乎有序的数组：优化后的冒泡排序在这种情况下效率很高。\n\n\n三、代码实现与优化(以下代码默认 using namespace std;)\n3.1 基础版本 (C++)1234567891011// 基础冒泡排序void bubbleSort(int arr[], int n) &#123;    for (int i = 0; i &lt; n - 1; i++) &#123;        // 每轮将一个最大值放到末尾        for (int j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr[j], arr[j + 1]);            &#125;        &#125;    &#125;&#125;\n\n3.2 优化版本 (C++)通过增加一个标志位，可以检测数组是否已经提前有序，从而避免不必要的遍历。\n12345678910111213141516// 优化版冒泡排序void optimizedBubbleSort(int arr[], int n) &#123;    for (int i = 0; i &lt; n - 1; i++) &#123;        bool swapped = false; // 交换标志位        for (int j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr[j], arr[j + 1]);                swapped = true;            &#125;        &#125;        // 如果在一轮遍历中没有发生交换，说明数组已有序        if (!swapped) &#123;            break;        &#125;    &#125;&#125;\n\n3.3 拓展：鸡尾酒排序鸡尾酒排序（Cocktail Shaker Sort）是冒泡排序的变体，它通过双向遍历来提升性能，既从左到右“冒泡”最大值，也从右到左“冒泡”最小值。\n1234567891011121314151617181920212223242526272829// 鸡尾酒排序void cocktailSort(int arr[], int n) &#123;    bool swapped = true;    int start = 0;    int end = n - 1;    while (swapped) &#123;        swapped = false;        // 从左到右，将最大值移动到末尾        for (int i = start; i &lt; end; ++i) &#123;            if (arr[i] &gt; arr[i + 1]) &#123;                swap(arr[i], arr[i + 1]);                swapped = true;            &#125;        &#125;        if (!swapped) break;        --end;        swapped = false;        // 从右到左，将最小值移动到开头        for (int i = end - 1; i &gt;= start; --i) &#123;            if (arr[i] &gt; arr[i + 1]) &#123;                swap(arr[i], arr[i + 1]);                swapped = true;            &#125;        &#125;        ++start;    &#125;&#125;\n\n\n四、知识检验4.1 测验题\n冒泡排序的平均时间复杂度是多少？\n为什么说冒泡排序是稳定的？\n对于一个已经完全排好序的数组，优化版的冒泡排序时间复杂度是多少？\n冒泡排序每一轮遍历结束后，能确定哪个元素的位置？\n除了设置标志位提前终止，还有其他优化冒泡排序的思路吗？\n\n4.2 测验答案\n平均时间复杂度是 O(n²)。\n因为只有当前一个元素严格大于后一个元素时才进行交换，相等元素之间的相对顺序不会改变。\n时间复杂度为 O(n)，因为它只需要完整遍历一次，发现没有发生任何元素交换后就会提前退出。\n每一轮结束后，都能确定当前未排序部分的最大元素的位置，并将其置于该部分的末尾。\n可以记录最后一次发生交换的位置，下一轮遍历时只需扫描到该位置即可，因为之后的部分已经是有序的了。\n\n\n五、练习与拓展5.1 推荐练习题 (LeetCode)\n\n\n推荐题目\n我的题解\n\n\n\n75. 颜色分类\n暂未完成\n\n\n283. 移动零\n暂未完成\n\n\n912. 排序数组\n暂未完成\n\n\n\n\n\n\n\n\n\n\n\n注意：虽然冒泡排序可以解决以上问题，但通常不是时间复杂度最优的解法，这些题目更适合用于加深对排序思想的理解。\n\n本文旨在帮助初学者理解冒泡排序的核心思想及应用，欢迎收藏和分享。\n","slug":"AlgorithmsDataStructures/排序算法/冒泡排序","date":"2025-07-18T04:00:00.000Z","categories_index":"算法与数据结构","tags_index":"排序","author_index":"Random"},{"id":"128d5f401a6627e4435b6e43e76ac072","title":"快速排序（Quick Sort）","content":"快速排序（Quick Sort）快速排序（Quick Sort）是一种极其高效的分治排序算法，也是实际应用中最常用的排序算法之一。它通过选择一个“基准”元素，将数组划分为两个子数组——一部分小于基准，另一部分大于基准，然后对这两个子数组递归地进行排序，最终使整个数组有序。\n\n一、算法原理1.1 核心思想快速排序的核心可以概括为“选个基准，然后左右站队”：\n\n选择基准 (Pivot)：从数组中任意选择一个元素作为“基准”。\n分区 (Partitioning)：重新排列数组，将所有小于基准的元素移动到基准的左边，所有大于或等于基准的元素移动到右边。完成这一步后，该基准元素就找到了它在最终有序序列中的正确位置。\n分而治之 (Divide and Conquer)：对基准左右两边的子数组（现在是两个独立的、更小的问题）递归地重复上述过程，直到每个子数组都排序完毕。\n\n1.2 详细步骤\n从数列中选择一个元素作为“基准”（本文示例采用最左侧元素）。\n执行分区操作：将所有比基准值小的元素放到基准前面，所有比基准值大的元素放到基准后面。\n对基准左右两个子序列分别重复步骤1和2，直到子序列只有一个元素或为空。\n\n1.3 示例演示以数组 [10, 7, 8, 9, 1, 5] 为例，排序过程如下（以最左侧元素为基准）：\n\n\n\n轮次\n操作描述\n当前数组状态\n\n\n\n第1轮\n初始数组: [10, 7, 8, 9, 1, 5]  选择基准: 10  分区结果: 将小于10的元素移到左侧\n[5, 7, 8, 9, 1, **10**]\n\n\n第2轮 (处理左子数组)\n当前子数组: [5, 7, 8, 9, 1]  选择基准: 5  分区结果: 将小于5的元素1移到左侧\n[1, **5**, 8, 9, 7]\n\n\n第3轮 (处理右子数组)\n当前子数组: [8, 9, 7]  选择基准: 8  分区结果: 将小于8的元素7移到左侧\n[1, 5, **7**, **8**, 9]\n\n\n完成\n所有子数组处理完毕，数组整体有序\n[1, 5, 7, 8, 9, 10]\n\n\n\n二、性能与特点2.1 复杂度分析\n时间复杂度\n最佳情况：O(n log n)\n平均情况：O(n log n)\n最坏情况：O(n²) - 当数组已排序或接近排序，且基准选择不佳时。\n\n\n空间复杂度：O(log n) - 主要用于递归调用的栈空间。\n稳定性：不稳定。因为分区过程中，相等元素的原始相对顺序可能会被改变。\n\n2.2 优缺点\n\n\n优点\n缺点\n\n\n\n平均效率高，是实际应用中最快的排序算法之一\n最坏情况性能差，时间复杂度退化至 O(n²)\n\n\n原地排序，空间复杂度低 (O(log n))\n不稳定的排序算法\n\n\n缓存友好，数据局部性好，访问模式高效\n对小数组不占优，可能比插入排序等更慢\n\n\n2.3 适用场景\n需要高效排序大量数据的场景。\n作为许多标准库（如C++ std::sort）的内部实现。\n对空间复杂度敏感，需要原地排序的应用。\n当不要求排序必须是稳定的时候。\n\n\n三、代码实现与优化(以下代码默认 using namespace std;)\n3.1 基础版本 (C++)1234567891011121314151617181920212223242526// 分区操作int partition(int arr[], int low, int high) &#123;    // 选择最左侧元素作为基准    int pivot = arr[low];    int i = low;    for (int j = low + 1; j &lt;= high; j++) &#123;        if (arr[j] &lt; pivot) &#123;            i++;            swap(arr[i], arr[j]);        &#125;    &#125;    // 将基准元素放到正确位置    swap(arr[low], arr[i]);    return i;&#125;// 快速排序主函数void quickSort(int arr[], int low, int high) &#123;    if (low &lt; high) &#123;        int pivotIndex = partition(arr, low, high);        // 递归排序左右子数组        quickSort(arr, low, pivotIndex - 1);        quickSort(arr, pivotIndex + 1, high);    &#125;&#125;\n\n3.2 优化策略 (C++)1. 随机化基准为避免在有序或近乎有序的数组上性能退化，可以随机选择一个元素作为基准。\n12345678// 随机化分区int randomPartition(int arr[], int low, int high) &#123;    // 随机选择一个基准，并与最左侧元素交换    srand(time(NULL));    int randomIndex = low + rand() % (high - low + 1);    swap(arr[randomIndex], arr[low]);    return partition(arr, low, high);&#125;\n\n2. 三数取中法选择数组的左端、中间和右端三个元素的中位数作为基准，可以更有效地避免最坏情况。\n12345678910111213141516// 三数取中获取基准并放到low位置void medianOfThree(int arr[], int low, int high) &#123;    int mid = low + (high - low) / 2;    if (arr[mid] &lt; arr[low]) swap(arr[mid], arr[low]);    if (arr[high] &lt; arr[low]) swap(arr[high], arr[low]);    if (arr[mid] &lt; arr[high]) swap(arr[mid], arr[low]); // 将中值放到low&#125;void quickSortWithMedian(int arr[], int low, int high) &#123;    if (low &lt; high) &#123;        medianOfThree(arr, low, high);        int pivotIndex = partition(arr, low, high);        quickSortWithMedian(arr, low, pivotIndex - 1);        quickSortWithMedian(arr, pivotIndex + 1, high);    &#125;&#125;\n\n\n四、知识检验4.1 测验题\n快速排序的平均时间复杂度是多少？\n快速排序是稳定的排序算法吗？为什么？\n使用最左侧元素作为基准的快速排序在什么情况下会出现最坏性能？\n快速排序的空间复杂度是多少？它主要由什么产生？\n\n4.2 测验答案\nO(n log n)。\n不是。因为在分区过程中，与基准相等的元素的相对位置可能会因为交换而改变。\n当数组已经排序或完全逆序时。此时每次分区都非常不平衡，导致递归树深度为 O(n)。\nO(log n)。它主要由递归调用产生的函数调用栈空间所决定。最坏情况下空间复杂度会达到 O(n)。\n\n\n五、练习与拓展5.1 推荐练习题 (LeetCode)\n\n\n推荐题目\n我的题解\n\n\n\n215. 数组中的第K个最大元素\n暂未完成\n\n\n912. 排序数组\n暂未完成\n\n\n75. 颜色分类\n暂未完成\n\n\n\n\n\n\n\n\n\n\n\n注意：虽然快速排序可以解决以上问题，但理解其核心的分区思想对于解决这类问题至关重要，不一定需要完整实现排序。\n\n本文旨在帮助初学者理解快速排序的核心思想及应用，欢迎收藏和分享。\n","slug":"AlgorithmsDataStructures/排序算法/快速排序","date":"2025-07-18T04:00:00.000Z","categories_index":"算法与数据结构","tags_index":"排序","author_index":"Random"},{"id":"f01cc273b0b1b737816c95524ea0b79c","title":"LeetCode-2367等差三元组的数目","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode - 2367.Number of Arithmetic Triplets\n解法一：三指针题目描述给定一个严格递增的整数数组 nums 和一个正整数 diff，请统计满足以下条件的三元组 (i, j, k) 的数量：\n\n三个下标满足：i &lt; j &lt; k\n数组元素满足：nums[j] - nums[i] == diff 且 nums[k] - nums[j] == diff\n\n换句话说，就是寻找等差数列长度为 3 的子序列个数，且公差为 diff。\n\n问题分析\n输入数组 nums 是严格递增的，这意味着 nums[i] &lt; nums[j] &lt; nums[k] 对于所有 i &lt; j &lt; k 都成立。\n题目核心就是寻找满足 nums[j] = nums[i] + diff 且 nums[k] = nums[j] + diff 的三元组。\n简单的暴力解法是三重循环枚举所有 (i, j, k)，时间复杂度为 O(n³)，在数据量较大时会超时。\n如何利用数组的有序特性，优化搜索过程？\n\n解题思路\n使用三个指针 i, j, k 分别表示三元组的三个位置。\n指针初始设置为：i = 0, j = 1, k = 2。\n固定 k 从索引 2 开始遍历，表示当前考察的三元组末尾元素。\n利用数组有序的特性，调整 j 和 i 指针使其满足：\nnums[j] + diff == nums[k]\nnums[i] + diff == nums[j]\n\n\n如果满足条件，则计数增加。\n指针只会向前移动，不回退，保证了时间复杂度为 O(n)。\n\n具体步骤\n对于每个 k（从 2 开始）：\n移动 j，使得 nums[j] + diff &gt;= nums[k]。\n如果 nums[j] + diff &gt; nums[k]，则该 k 不满足条件，跳过。\n否则，移动 i，使得 nums[i] + diff &gt;= nums[j]。\n如果 nums[i] + diff == nums[j]，说明找到一个满足条件的三元组，计数加 1。\n\n\n\n1234567891011121314151617181920class Solution &#123;public:    int arithmeticTriplets(vector&lt;int&gt;&amp; nums, int diff) &#123;        int i = 0, j = 1, ans = 0;        for (int k = 2; k &lt; nums.size(); k++) &#123;            // 移动j指针，直到 nums[j] + diff &gt;= nums[k]            while (j &lt; k &amp;&amp; nums[j] + diff &lt; nums[k]) ++j;            // 如果 nums[j] + diff 不等于 nums[k]，继续下一个 k            if (j == k || nums[j] + diff &gt; nums[k]) continue;            // 移动i指针，直到 nums[i] + diff &gt;= nums[j]            while (i &lt; j &amp;&amp; nums[i] + diff &lt; nums[j]) ++i;            // 如果 nums[i] + diff 等于 nums[j]，说明找到一个等差三元组            if (i &lt; j &amp;&amp; nums[i] + diff == nums[j]) ans++;        &#125;        return ans;    &#125;&#125;;\n\n解法二：哈希表\n由于数组严格递增，也可以使用哈希集合保存所有元素。\n遍历数组元素 num，判断 num + diff 和 num + 2 * diff 是否存在。\n这种方法代码更简洁，时间复杂度仍为 O(n)，空间换时间。\n\n示例代码：\n12345678910111213class Solution &#123;public:    int arithmeticTriplets(vector&lt;int&gt;&amp; nums, int diff) &#123;        unordered_set&lt;int&gt; s(nums.begin(), nums.end());        int ans = 0;        for (int num : nums) &#123;            if (s.count(num + diff) &amp;&amp; s.count(num + 2 * diff)) &#123;                ans++;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n对比双指针和哈希法\n双指针方法不需要额外空间，适合对空间敏感的场景。\n哈希方法代码更简洁，查找速度快，但需额外空间。\n选择合适的方法依据具体场景和数据规模。\n\n","slug":"LeetCode/LeetCode-2367等差三元组的数目","date":"2025-07-17T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"50923e38d6714eed297b6e077bc9df21","title":"LeetCode-42接雨水","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode - 42. Trapping Rain Water\n解法一：相向双指针题目思路：双指针法 + 局部最值本题的目标是，给定一个整数数组 height，其中每个元素代表一个单位宽度的柱子的高度，求这些柱子可以接住多少单位的雨水。\n算法核心思想：我们使用 双指针法 从两边向中间遍历，同时记录当前左右的最大高度 tL 和 rL。每次比较左右最大值，谁小就移动谁的指针，这样可以确保当前指针所处位置可以接的雨水只依赖于较小的一边。\n定义：\nl, r: 左右指针，初始指向数组两端。\ntL, rL: 当前指针左侧和右侧的最大高度。\nans: 最终答案，即累计接住的雨水量。\n\n1234567891011121314151617181920212223242526class Solution &#123;public:\tint trap(vector&lt;int&gt;&amp; height) &#123;\t    int n = height.size();        // 柱子的总数\t    int l = 0, r = n - 1;         // 左右指针\t    int tL = 0, rL = 0;           // 左右的最高柱子\t    int ans = 0;                  // 接住的雨水总量\t    \t    while (l &lt; r) &#123;\t        // 更新左右最大高度\t        tL = max(tL, height[l]);\t        rL = max(rL, height[r]);\t        // 谁的最大高度更小，就看谁那边能不能接水\t        if (tL &lt; rL) &#123;\t            ans += tL - height[l];  // 左边接水 = 左最大高度 - 当前高度\t            l++;                    // 移动左指针\t        &#125; else &#123;\t            ans += rL - height[r];  // 右边接水 = 右最大高度 - 当前高度\t            r--;                    // 移动右指针\t        &#125;\t    &#125;\t\t    return ans;\t&#125;&#125;;\n\n\n\n示例分析：输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6\n解释：\n接水的区域如下图所示（柱状图视角）：\n123    █ █   █ ██ █ ███\n\n接水量：1 + 1 + 2 + 1 + 1 = 6\n","slug":"LeetCode/LeetCode-42接雨水","date":"2025-07-16T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"ffcfdc2657e27f0f1d5678cd568c11ab","title":"算法复杂度一览表","content":"时间空间复杂度常见情况🧊时间\n\n\n名称\n记号\n说明\n典型例子\n\n\n\n常数阶\nO(1)\n不随输入规模变化\n访问数组某个元素\n\n\n对数阶\nO(log n)\n输入每次减半\n二分查找、平衡二叉搜索树操作\n\n\n线性阶\nO(n)\n遍历整个输入\n顺序查找、遍历数组\n\n\n线性对数阶\nO(n log n)\n分治递归 + 遍历\n快排、归并排序、堆排序\n\n\n平方阶\nO(n²)\n嵌套两层循环\n冒泡排序、选择排序、插入排序\n\n\n立方阶\nO(n³)\n三层嵌套循环\nFloyd 最短路径\n\n\n指数阶\nO(2ⁿ)\n枚举所有组合\n子集生成、背包问题暴力递归\n\n\n阶乘阶\nO(n!)\n全排列枚举\n旅行商问题暴力解、n皇后问题\n\n\n🧊 空间\n\n\n空间复杂度\n示例\n\n\n\nO(1)\n原地排序、双指针、滑动窗口\n\n\nO(n)\n需要额外数组、哈希表、栈、队列\n\n\nO(n²)\n二维矩阵（如图算法、DP表）\n\n\n💡 小技巧：估算能不能过\n\n\n输入规模 n\n推荐算法复杂度上限\n\n\n\nn ≤ 10\nO(n!) 可接受\n\n\nn ≤ 20\nO(2ⁿ) 可接受\n\n\nn ≤ 1e2\nO(n³) 可接受\n\n\nn ≤ 1e4\nO(n²) 可接受\n\n\nn ≤ 1e5\nO(n log n) 必须\n\n\nn ≤ 1e6\nO(n) 最佳\n\n\n\n算法与数据结构复杂度一览表本表系统整理了算法复杂度的核心概念及常见算法&#x2F;数据结构在时间和空间复杂度上的表现，便于查阅和对比。\n\n一、什么是算法复杂度？算法复杂度是衡量算法性能的重要指标，主要包括时间复杂度（执行所需时间）和空间复杂度（所需内存），常用**大O表示法（Big O Notation）**描述在最坏情况下的上界。\n\n二、常见时间复杂度和空间复杂度\n\n\n表达式\n名称\n举例\n\n\n\nO(1)\n常数\n数组访问、哈希查找\n\n\nO(log n)\n对数\n二分查找\n\n\nO(n)\n线性\n遍历数组\n\n\nO(n log n)\n线性对数\n归并排序、快速排序\n\n\nO(n²)\n平方\n冒泡排序、插入排序\n\n\nO(2ⁿ)\n指数\n递归斐波那契、子集生成\n\n\nO(n!)\n阶乘\n全排列问题\n\n\n\n三、排序算法复杂度\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n冒泡排序\nO(n)\nO(n²)\nO(n²)\nO(1)\n\n\n选择排序\nO(n²)\nO(n²)\nO(n²)\nO(1)\n\n\n插入排序\nO(n)\nO(n²)\nO(n²)\nO(1)\n\n\n归并排序\nO(n log n)\nO(n log n)\nO(n log n)\nO(n)\n\n\n快速排序\nO(n log n)\nO(n log n)\nO(n²)\nO(log n)\n\n\n堆排序\nO(n log n)\nO(n log n)\nO(n log n)\nO(1)\n\n\n计数排序\nO(n + k)\nO(n + k)\nO(n + k)\nO(n + k)\n\n\n基数排序\nO(nk)\nO(nk)\nO(nk)\nO(n + k)\n\n\n桶排序\nO(n)\nO(n + k)\nO(n²)\nO(n + k)\n\n\n希尔排序\nO(n log n)\nO(n log² n)\nO(n²)\nO(1)\n\n\n\n四、查找算法复杂度\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n线性查找\nO(1)\nO(n)\nO(n)\nO(1)\n\n\n二分查找\nO(1)\nO(log n)\nO(log n)\nO(1)\n\n\n跳跃查找\nO(1)\nO(√n)\nO(√n)\nO(1)\n\n\n插值查找\nO(1)\nO(log log n)\nO(n)\nO(1)\n\n\n哈希查找\nO(1)\nO(1)\nO(n)\nO(n)\n\n\n\n五、线性数据结构复杂度\n\n\n结构&#x2F;操作\n最佳\n平均\n最差\n空间复杂度\n\n\n\n数组-访问\nO(1)\nO(1)\nO(1)\nO(1)\n\n\n数组-插入&#x2F;删除\nO(1)\nO(n)\nO(n)\nO(1)\n\n\n链表-访问\nO(1)\nO(n)\nO(n)\nO(1)\n\n\n链表-插入&#x2F;删除\nO(1)\nO(1)\nO(1)\nO(1)\n\n\n栈&#x2F;队列-操作\nO(1)\nO(1)\nO(1)\nO(1)\n\n\n\n六、树形数据结构复杂度\n\n\n结构&#x2F;操作\n最佳\n平均\n最差\n空间复杂度\n\n\n\n二叉搜索树-查找\nO(log n)\nO(log n)\nO(n)\nO(1)\n\n\nAVL树&#x2F;红黑树\nO(log n)\nO(log n)\nO(log n)\nO(n)\n\n\n堆-操作\nO(1)\nO(log n)\nO(log n)\nO(1)\n\n\nTrie树-操作\nO(m)\nO(m)\nO(m)\nO(nm)\n\n\n\n七、图形数据结构复杂度\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n邻接矩阵 - 访问&#x2F;搜索&#x2F;插入&#x2F;删除\nO(1)\nO(1)\nO(1)\nO(V²)\n\n\n邻接矩阵 - 遍历\nO(V²)\nO(V²)\nO(V²)\nO(V²)\n\n\n邻接表 - 访问\nO(1)\nO(1)\nO(V)\nO(V+E)\n\n\n邻接表 - 搜索\nO(1)\nO(V)\nO(V)\nO(V+E)\n\n\n邻接表 - 插入\nO(1)\nO(1)\nO(1)\nO(V+E)\n\n\n邻接表 - 删除\nO(1)\nO(E)\nO(E)\nO(V+E)\n\n\n邻接表 - 遍历\nO(V+E)\nO(V+E)\nO(V+E)\nO(V+E)\n\n\n边列表 - 访问&#x2F;搜索\nO(1)\nO(E)\nO(E)\nO(E)\n\n\n边列表 - 插入&#x2F;删除\nO(1)\nO(1)\nO(1)\nO(E)\n\n\n边列表 - 遍历\nO(E)\nO(E)\nO(E)\nO(E)\n\n\n有向&#x2F;无向&#x2F;加权图-基本操作\nO(1)\nO(V+E)\nO(V+E)\nO(V+E)\n\n\n有向无环图(DAG)-基本操作\nO(1)\nO(V+E)\nO(V+E)\nO(V+E)\n\n\n\n\n\n\n\n\n\n\n\n注：V为顶点数，E为边数。\n\n八、哈希与映射\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n哈希表-操作\nO(1)\nO(1)\nO(n)\nO(n)\n\n\n布隆过滤器\nO(k)\nO(k)\nO(k)\nO(m)\n\n\n\n九、高级数据结构\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n并查集\nO(1)\nO(α(n))\nO(α(n))\nO(n)\n\n\n跳表\nO(log n)\nO(log n)\nO(n)\nO(n)\n\n\n\n十、图论算法\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\nBFS&#x2F;DFS\nO(V+E)\nO(V+E)\nO(V+E)\nO(V)\n\n\nDijkstra\nO(V²+E)\nO(V²+E)\nO(V²+E)\nO(V)\n\n\nBellman-Ford\nO(VE)\nO(VE)\nO(VE)\nO(V)\n\n\nFloyd-Warshall\nO(V³)\nO(V³)\nO(V³)\nO(V²)\n\n\nKruskal\nO(E log E)\nO(E log E)\nO(E log E)\nO(V+E)\n\n\nPrim\nO(E log V)\nO(E log V)\nO(E log V)\nO(V)\n\n\n拓扑排序\nO(V+E)\nO(V+E)\nO(V+E)\nO(V)\n\n\n\n十一、字符串和数论算法字符串算法\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\nKMP算法\nO(n)\nO(m+n)\nO(m+n)\nO(m)\n\n\nRabin-Karp算法\nO(n)\nO(m+n)\nO(mn)\nO(1)\n\n\nBoyer-Moore算法\nO(n&#x2F;m)\nO(n)\nO(mn)\nO(m)\n\n\n数论算法\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n欧几里得算法(GCD)\nO(1)\nO(log min(a,b))\nO(log min(a,b))\nO(1)\n\n\n快速幂\nO(log n)\nO(log n)\nO(log n)\nO(1)\n\n\n埃拉托斯特尼筛法\nO(n log log n)\nO(n log log n)\nO(n log log n)\nO(n)\n\n\n模逆元计算\nO(n³)\nO(n³)\nO(n³)\nO(n²)\n\n\n\n十二、复杂度分析与算法选择建议\n根据输入数据规模、时间效率要求、内存限制等选取算法；\n合理利用空间换时间、分治、动态规划等优化策略；\n选择适合场景的数据结构（如查找优先用哈希&#x2F;二分查找，稀疏图用邻接表等）。\n\n\n\n\n\n\n\n\n\n\n\n本表仅供速查，实际复杂度可能因具体实现、输入分布和硬件环境而有所不同。\n","slug":"AlgorithmsDataStructures/其他/算法复杂度一览表","date":"2025-07-14T16:00:00.000Z","categories_index":"算法与数据结构","tags_index":"","author_index":"Random"}]