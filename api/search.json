[{"id":"089c311222389ee62ce5169132fe0b41","title":"从零到一：你的第一堂C语言入门课","content":"\n\n\n\n\n\n\n\n\n本文所有代码均在以下环境中测试通过，运行稳定、输出正确：\n\n操作系统：Windows 11 专业版 64位\n开发工具：Dev-C++ 5.11\n\n\n第一节：C语言-开启编程世界的大门C 语言是一门古老而强大的通用编程语言。它于 1972 年由丹尼斯·里奇 (Dennis Ritchie) 在贝尔实验室创造，最初是为了开发 UNIX 操作系统。如今，尽管涌现出无数现代编程语言，C 语言依然是许多技术领域的核心，活跃在操作系统、嵌入式设备、高性能计算、编译器、数据库等底层开发中，是名副其实的“数字世界的基石”。\n1. 为什么 C 语言是初学者的绝佳选择？对于编程新手而言，学习 C 语言将为你带来无与伦比的优势：\n\n打下坚实的编程基础：C 语言是许多现代语言（如 C++、Java、Go）的“祖师爷”。掌握了它的核心语法和编程思想，再学习其他语言会事半功倍。\n深入理解计算机工作原理：C 语言让你能直接与内存对话，这有助于你理解程序在底层是如何运行的，建立起清晰的“计算机思维模型”。\n培养严谨的编码习惯：由于需要手动管理内存等资源，C 语言会促使你养成严谨、高效的编码习惯，这对长远的职业发展至关重要。\n解锁广阔的技术领域：学好 C 语言，就等于拿到了进入数据结构、算法、操作系统、嵌入式开发等高阶技术领域的“入场券”。\n\n2. C 语言的核心特点\n结构化语言：采用模块化的设计，代码层次清晰，易于理解和维护。\n极致的高效性：代码会被编译成贴近硬件的机器码，运行速度极快，资源消耗少，是追求性能的“不二之选”。\n强大的可移植性：遵循 ANSI&#x2F;ISO 标准的 C 代码，几乎无需修改就能在不同的操作系统和硬件平台上编译运行。\n简洁且灵活：语法规则不多，但通过指针等特性赋予了程序员极高的操作自由度。\n\n3. 学习 C 语言需要什么？别担心，C 语言非常适合零基础入门。你只需要：\n\n一台电脑：并掌握基本的开关机、打字和文件操作。\n一颗好奇且坚韧的心：乐于动手实践，不畏惧 bug 和报错，享受解决问题的过程。\n\n4. 你的第一个 C 程序：Hello, World!让我们用一个经典的例子来感受 C 语言的魅力。\n123456#include &lt;stdio.h&gt;int main() &#123;    printf(&quot;Hello, World!\\n&quot;);    return 0;&#125;\n\n这个简单的程序展示了 C 代码的基本结构。看不懂别担心，我们很快就会逐一揭开它们的神秘面纱。准备好进入精彩的编程世界了吗？\n\n第二节：搭建开发环境与你的第一个程序在上一节，我们了解了 C 语言。现在，理论学习告一段落，让我们立刻进入激动人心的实践环节！本节将手把手地指导你搭建 C 语言开发环境，并成功编写、运行你的第一个程序。\n1. 准备你的“兵器库”：安装 Dev-C++要让计算机听懂我们用 C 语言下达的指令，需要一个专门的“翻译官”——编译器 (Compiler)。同时，我们还需要一个地方来编写代码，这就是代码编辑器 (Code Editor)。\n为了方便初学者，我们通常使用集成开发环境 (IDE, Integrated Development Environment)，它将编辑器、编译器以及其他实用工具（如调试器）打包在一起，让我们能专注于编程本身。\n\n\n\n\n\n\n\n\n\n【本教程测试环境说明】\n为了保证学习过程的顺畅，建议您也安装和使用 Dev-C++（点击下载）。\n2. 载入史册的第一个程序：”Hello, World!”安装好 Dev-C++ 后，让我们启动它，通过编写史上最著名的程序 “Hello, World!” 来揭开 C 语言的神秘面纱。\n操作步骤：\n\n打开 Dev-C++。\n点击菜单栏的 文件(F) -&gt; 新建(N) -&gt; 源代码(S)，或者直接使用快捷键 Ctrl + N。\n在新打开的编辑区中，完整地输入以下代码：\n\n12345678#include &lt;stdio.h&gt;int main() &#123;    // 我们的第一个C程序，向世界问好！    printf(&quot;Hello, World!\\n&quot;);        return 0;&#125;\n\n3. 逐行解密：”Hello, World!” 的内在逻辑这段代码虽然简短，却包含了 C 程序的基本结构。让我们把它拆开，看看每一部分都在做什么。对于以下内容不理解也不要紧，后续我们会逐步系统学习。\n\n#include &lt;stdio.h&gt;\n\n这是一个预处理指令。它的作用是在编译之前，把 C 语言标准库中的 stdio.h 文件“包含”进来。stdio 是“标准输入输出 (Standard Input&#x2F;Output)”的缩写，这个文件里包含了我们后面要用的 printf 函数的声明。\n\n\nint main()\n\nmain 函数是主函数，是整个 C 程序的唯一入口。无论你的程序多么复杂，代码总是从 main 函数的第一行开始执行。\nint 表示 main 函数执行结束后，会返回一个整数值。\n() 表明 main 是一个函数。\n\n\n&#123; ... &#125;\n\n这对花括号定义了 main 函数的函数体。所有属于 main 函数的代码都必须写在这对大括号内部。\n\n\n// 我们的第一个C程序...\n\n这是注释。以 // 开头的单行注释或者用 /* ... */ 包围的多行注释，是写给程序员看的笔记，用于解释代码。编译器在编译时会自动忽略它们。\n\n\nprintf(&quot;Hello, World!\\n&quot;);\n\n这是程序的核心执行语句。\nprintf 是一个定义在 stdio.h 中的库函数，功能是向屏幕（控制台）输出指定的文本。\n&quot;Hello, World!\\n&quot; 是一个字符串，是我们要打印的具体内容。\n\\n 是一个转义字符，意思是换行。它告诉电脑，在打印完 “Hello, World!” 之后，把光标移动到下一行的开头。\nC 语言中，大多数语句都必须以英文分号 ; 结尾，它代表一个语句的结束。初学者最常犯的错误就是忘记写分号！\n\n\nreturn 0;\n\n这条语句用于结束 main 函数，并向操作系统返回一个值。\n返回 0 是一个普遍的约定，代表程序已经正常运行并成功退出。如果返回其他非零值，通常表示程序在运行中遇到了错误。\n\n\n\n4. 编译与运行：见证奇迹的时刻代码写好后，我们需要让 Dev-C++ 把它变成可执行的程序。\n\n保存文件：点击菜单栏 文件(F) -&gt; 保存(S) (快捷键 Ctrl + S)。在弹出的窗口中，将文件名命名为 hello.c，并选择一个你找得到的位置保存它。（注意，后缀名 .c 表示这是一个 C 语言源文件）。\n\n编译并运行：这是最关键的一步！点击菜单栏 运行(E) -&gt; 编译并运行(R)，或者直接按下键盘上的 F11 键。\n\n\nDev-C++ 会自动完成“编译”和“运行”两个动作。如果代码没有错误，一个黑色的命令行窗口将会弹出，显示如下内容：\n123Hello, World!--------------------------------\n\n恭喜你！ 你已经成功地搭建了开发环境，并亲手让计算机向世界发出了问候。你已经正式迈出了成为一名程序员的第一步。\n在下一节中，我们将深入学习 C 语言的基本元素——变量与数据类型，开始真正地处理数据。\n\n学习路线图 &amp; 后续章节预告为了帮助您建立最扎实的 C 语言基础，我们精心设计了以下学习路径。本教程将带您从零开始，一步步带您入门C语言！\n\n \n第一节：初识 C 语言——开启编程世界的大门\n\n \n第二节：环境搭建——磨亮你的第一把“神兵利器”\n\n \n第三节：变量与输入输出——让程序拥有“记忆”并与你“对话”\n\n\n\n\n\n\n\n\n\n核心内容：int, float, char 等数据类型，printf 输出，scanf 输入。\n\n \n第四节：运算符与表达式——程序世界的“加减乘除”\n\n\n\n\n\n\n\n\n\n核心内容：算术、关系、逻辑运算符，数据类型的转换。\n\n \n第五节：流程控制——教会计算机如何“思考”与“重复”\n\n\n\n\n\n\n\n\n\n核心内容：if-else 条件判断，switch 多路选择，for 与 while 循环结构。\n\n \n第六节：数组——批量数据的超级管家\n\n\n\n\n\n\n\n\n\n核心内容：一维与二维数组的声明、初始化和使用。\n\n \n第七节：函数——代码的“乐高积木”\n\n\n\n\n\n\n\n\n\n核心内容：函数的定义与调用，参数传递，返回值，模块化编程思想。\n\n \n第八节：指针——探寻 C 语言的灵魂\n\n\n\n\n\n\n\n\n\n核心内容：内存地址，指针变量，指针与数组、指针与函数的结合使用。\n\n \n第九节：结构体——打造专属你的数据类型\n\n\n\n\n\n\n\n\n\n核心内容：结构体的定义与使用，管理复杂数据。\n\n \n更多进阶章节敬请期待！\n\n\n\n\n\n\n\n\n\n\n\n我们致力于提供系统、准确且充满乐趣的 C 语言入门教程。在学习的旅程中，遇到任何问题都欢迎您在评论区留言讨论，让我们共同进步！\n","slug":"从零到一：你的第一堂C语言入门课","date":"2025-09-01T00:00:00.000Z","categories_index":"C/C++","tags_index":"","author_index":"Random"},{"id":"5218050a0cad171f58cef1b0ffd5e306","title":"2025暑假分享","content":"本文总结2025年暑假每日分享，点击下方表格中的链接可快速跳转至对应位置。\n此处为按类型总结，如需按时间顺序请访问 Github\n\n\n\n日期\n分类\n题目名称\n题目链接\n\n\n\n0713\n双指针基础\n盛最多水的容器\n\n\n\n0714\n双指针基础\n删除有序数组中的重复项 II\n\n\n\n0715\n双指针基础\n反转字符串中的单词\n\n\n\n0716\n双指针提升\n接雨水\n\n\n\n0717\n双指针提升\n等差三元组的数目\n\n\n\n0722\n查找算法\n在排序数组中查找元素的第一个和最后一个位置\n\n\n\n0723\n查找算法\n寻找比目标字母大的最小字母\n\n\n\n0702\n查找算法\n数组搜索\n\n\n\n0727\n选择算法\n数组中的第K个最大元素（快速选择）\n\n\n\n0728\n选择算法\n数组中的第K个最大元素（堆选择法）\n\n\n\n0718\n排序算法\n排序数组（快速排序）\n\n\n\n0724\n排序算法\n排序数组（归并排序）\n\n\n\n0725\n排序算法\n排序数组（堆排序）\n\n\n\n0726\n排序算法\n排序数组（基数排序）\n\n\n\n0719\n链表基础\n合并两个有序链表\n\n\n\n0720\n链表基础\n两数相加\n\n\n\n0721\n链表基础\n分隔链表\n\n\n\n0701\n模拟\n小码哥幸运日\n\n\n\n0703\n模拟\n小码哥的艰难选择\n\n\n\n0706\n模拟&#x2F;字符串\n科学记数法\n\n\n\n0707\n模拟\n小码哥搭建花圃\n\n\n\n0709\n模拟&#x2F;贪心\n小码哥玩游戏\n\n\n\n0704\n字符串处理\n小码哥的英语\n\n\n\n0708\n贪心策略\n大促销\n\n\n\n0710\n数学\n奇怪的数\n\n\n\n0711\n数学\n快速计算\n\n\n\n0712\n数学\n因数\n\n\n\n0705\n数学\n最小公倍数\n\n\n\n0728\n位运算\n只出现一次的数字\n\n\n\n0729\n位运算\n只出现一次的数字 II\n\n\n\n0730\n位运算\n只出现一次的数字 III\n\n\n\n0731\n位运算\n丢失的数字\n\n\n\n","slug":"2025暑假分享","date":"2025-08-31T10:00:00.000Z","categories_index":"算法题解","tags_index":"","author_index":"Random"},{"id":"1ef7b5c1febefbecd2fae064a2008e72","title":"LeetCode-744寻找比目标字母大的最小字母","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode 744. Find Smallest Letter Greater Than Target\n题目描述给定一个递增排序的字符数组 letters（可能包含环绕），和一个目标字符 target，要求返回数组中大于 target 的最小字符。\n若不存在满足条件的字符，则返回 letters[0]，即“首位环绕”。\n\n解法一：二分这是一个经典的二分查找问题，目标是找出 第一个大于 target 的字符。可以直接套用「变形版 upper_bound 模板」，即：\n12345if (letters[mid] &lt;= target) &#123;    l = mid + 1;&#125; else &#123;    r = mid - 1;&#125;\n\n\n当 letters[mid] &lt;= target：说明 mid 及其左侧都不符合要求，目标在右边 → l = mid + 1\n当 letters[mid] &gt; target：mid 是一个候选答案，尝试向左搜索更小的 → r = mid - 1\n\n最后循环结束时，l 会指向第一个满足 letters[l] &gt; target 的元素。\n\n环绕处理当 target 大于等于所有字符时，l 会超出数组长度（即 l == letters.size()），这时应该返回数组开头的字符 letters[0]。\n代码中用到了：\n1letters[l % letters.size()]\n\n这个技巧巧妙地利用取模操作实现了首尾环绕处理，可以避免边界判断。\n\n代码123456789101112131415class Solution &#123;public:    char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123;        int l = 0, r = letters.size() - 1;        while (l &lt;= r) &#123;            int mid = l + ((r - l) &gt;&gt; 1);            if (letters[mid] &lt;= target) &#123;                l = mid + 1;            &#125; else &#123;                r = mid - 1;            &#125;        &#125;        return letters[l % letters.size()];    &#125;&#125;;\n\n\n举个例子输入：\n1letters = [&#x27;c&#x27;, &#x27;f&#x27;, &#x27;j&#x27;], target = &#x27;d&#x27;\n\n查找过程中：\n\nmid &#x3D; 1 → letters[1]&#x3D;’f’ &gt; ‘d’，缩小右边界 r&#x3D;0\nmid &#x3D; 0 → letters[0]&#x3D;’c’ &lt;&#x3D; ‘d’，l&#x3D;1\n循环结束，l&#x3D;1，返回 letters[1]&#x3D;’f’\n\n\n总结这题考察的是二分搜索在查找「第一个大于目标」元素时的使用方式，配合 % letters.size() 做环绕处理，逻辑清晰又简洁\n","slug":"LeetCode/LeetCode-744寻找比目标字母大的最小字母","date":"2025-07-23T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"c8e3ec39a2bdb46713f60afe507c2dde","title":"LeetCode-34在排序数组中查找元素的第一个和最后一个位置","content":"\n\n\n\n\n\n\n\n\n题目链接： LeetCode 34. Find First and Last Position of Element in Sorted Array\n题目描述给定一个按 非递减顺序 排列的整数数组 nums，以及一个整数 target，请找出 target 在数组中出现的 第一个 和 最后一个位置。\n\n如果数组中不存在目标值 target，返回 [-1, -1]。\n要求时间复杂度为 O(log n)，使用二分查找。\n\n\n解题思路本质是二分查找的两次应用：\n第一次二分查找：找出目标值 target 的左边界（第一个等于 target 的位置）。\n第二次二分查找：找出目标值 target 的右边界（最后一个等于 target 的位置）。\n\n注意事项：\n数组可能不存在 target，需单独判断。\n二分写法需根据使用的是哪种区间（闭区间、左闭右开、开区间）进行边界调整。\n\n\n解法一：左闭右闭区间 [left, right]123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public:    // 查找 target 的左边界（第一个等于 target 的位置）    int findLeft(const vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;  // 左闭右闭区间 [left, right]            int mid = left + (right - left) / 2;            if (nums[mid] &lt; target) &#123;                left = mid + 1;  // target 在右边            &#125; else &#123;                right = mid - 1; // 向左收缩（即使等于也继续左边找）            &#125;        &#125;        // 检查 left 是否越界 或 是否是 target        if (left &lt; nums.size() &amp;&amp; nums[left] == target) return left;        return -1;    &#125;    // 查找 target 的右边界（最后一个等于 target 的位置）    int findRight(const vector&lt;int&gt;&amp; nums, int target) &#123;        int left = 0, right = nums.size() - 1;        while (left &lt;= right) &#123;  // 左闭右闭区间 [left, right]            int mid = left + (right - left) / 2;            if (nums[mid] &gt; target) &#123;                right = mid - 1; // target 在左边            &#125; else &#123;                left = mid + 1;  // 向右收缩（即使等于也继续右边找）            &#125;        &#125;        // 检查 right 是否越界 或 是否是 target        if (right &gt;= 0 &amp;&amp; nums[right] == target) return right;        return -1;    &#125;    // 主函数：返回目标值的起始和结束位置    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;        int left = findLeft(nums, target);        if (left == -1) return &#123;-1, -1&#125;;  // target 不存在        int right = findRight(nums, target);        return &#123;left, right&#125;;    &#125;&#125;;\n\n\n解法二：左闭右开区间：待更新\n解法三：开区间 ：待更新\n示例测试用例\n\n\n输入\n输出\n说明\n\n\n\nnums = [5,7,7,8,8,10] target = 8\n[3,4]\ntarget 存在，返回区间位置\n\n\nnums = [5,7,7,8,8,10] target = 6\n[-1,-1]\ntarget 不存在\n\n\nnums = [] target = 0\n[-1,-1]\n空数组\n\n\n","slug":"LeetCode/LeetCode-34在排序数组中查找元素的第一个和最后一个位置","date":"2025-07-22T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"3db473fdf9b2739246e485648c59f7e1","title":"LeetCode-86分隔链表","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode 86. Partition List\n题目描述给定一个链表 head 和一个特定值 x，请将所有小于 x 的节点排在大于或等于 x 的节点之前。\n你应该保留原始相对顺序。\n示例：12输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5\n\n\n解法一：模拟我们将链表划分为两个部分：\n\n一个链表保存 小于 x 的节点（记为 left 链表）；\n一个链表保存 大于等于 x 的节点（记为 right 链表）；\n最后将两个链表拼接起来。\n\n关键点：\n使用 leftHead 和 leftTail 维护左边链表；\n使用 rightHead 和 rightTail 维护右边链表；\n使用 head-&gt;next = nullptr 断开原链表，避免成环。\n\n\n动图理解（文字版）假设原链表为：\n12head: 1 → 4 → 3 → 2 → 5 → 2x = 3\n\n处理过程如下：\n\n遇到 1 → 放入 left 链表\n遇到 4 → 放入 right 链表\n遇到 3 → 放入 right 链表\n遇到 2 → 放入 left 链表\n遇到 5 → 放入 right 链表\n遇到 2 → 放入 left 链表\n\n最终：\n123left: 1 → 2 → 2right: 4 → 3 → 5结果: 1 → 2 → 2 → 4 → 3 → 5\n\n\n代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public:    ListNode* partition(ListNode* head, int x) &#123;        // 定义左右两个链表的头尾指针        ListNode *leftHead = nullptr, *leftTail = nullptr;        ListNode *rightHead = nullptr, *rightTail = nullptr;        while (head != nullptr) &#123;            ListNode* next = head-&gt;next;  // 保存下一个节点            head-&gt;next = nullptr;         // 当前节点断链，避免成环            if (head-&gt;val &lt; x) &#123;          // 小于 x 放左边                if (leftHead == nullptr)  // 初始化左链表                    leftHead = head;                else                    leftTail-&gt;next = head;                leftTail = head;          // 移动尾指针            &#125; else &#123;                      // 大于等于 x 放右边                if (rightHead == nullptr)                    rightHead = head;                else                    rightTail-&gt;next = head;                rightTail = head;            &#125;            head = next;  // 处理下一个节点        &#125;        // 连接左右链表        if (leftHead == nullptr) return rightHead;        leftTail-&gt;next = rightHead;        return leftHead;    &#125;&#125;;\n\n\n边界处理要点\n如果原链表为空（head 为 nullptr），函数会自动返回 nullptr。\n如果所有节点都 ≥ x，则 leftHead 为 nullptr，直接返回 rightHead。\nhead-&gt;next = nullptr; 非常关键，避免原链表中断开或形成环。\n左链表和右链表保持原始节点顺序（因为只操作 next）。\n\n\n示例\n\n\n输入\nx\n输出\n\n\n\n1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2\n3\n1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5\n\n\n2-&gt;1\n2\n1-&gt;2\n\n\n5-&gt;6-&gt;7\n4\n5-&gt;6-&gt;7\n\n\n1-&gt;2-&gt;3\n10\n1-&gt;2-&gt;3\n\n\n空链表 nullptr\n1\nnullptr\n\n\n","slug":"LeetCode/LeetCode-86分隔链表","date":"2025-07-21T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"2e0b75e87a11aa9fe9b055b9179f2839","title":"LeetCode-2两数相加","content":"\n\n\n\n\n\n\n\n\n题目链接： LeetCode 2. Add Two Numbers）\n题目描述给你两个 非空 的链表 l1 和 l2，它们表示两个 非负整数，每位数字都是逆序存储 的，每个节点只存储一位数字。\n请你将这两个数相加，并以同样形式返回一个代表和的链表。\n示例：123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807\n\n\n解法一：模拟由于两个数是以逆序存储的，所以我们可以从两个链表的头部开始逐位相加：\n\n模拟竖式加法：从低位开始相加（即从链表头开始），依次处理进位。\n每次处理一位，并创建一个新节点表示该位结果。\n若最后还有进位，则需要额外加一个新节点。\n\n\n步骤\n定义两个指针：head 为结果链表头，cur 为当前操作指针；\n定义变量 carry = 0 表示进位；\n遍历 l1 和 l2 的每一位数字：\n若某一链表已结束，则看作是 0；\n计算当前位 sum = val1 + val2 + carry；\n当前位值为 sum % 10，进位为 sum / 10；\n\n\n如果最后进位 carry &gt; 0，则加上一个新节点；\n返回结果链表头 head。\n\n\n代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        ListNode *head = nullptr, *cur = nullptr;        int carry = 0;        // 遍历 l1 和 l2 的每一位        for (int sum, val; l1 != nullptr || l2 != nullptr;             l1 = (l1 == nullptr ? nullptr : l1-&gt;next),             l2 = (l2 == nullptr ? nullptr : l2-&gt;next)) &#123;                        // 当前位和 = l1值 + l2值 + 上一位进位            sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + carry;            val = sum % 10;     // 当前位数字            carry = sum / 10;   // 进位            // 创建节点并接入链表            if (head == nullptr) &#123;                head = new ListNode(val);                cur = head;            &#125; else &#123;                cur-&gt;next = new ListNode(val);                cur = cur-&gt;next;            &#125;        &#125;        // 如果还有进位，最后加一位        if (carry == 1) &#123;            cur-&gt;next = new ListNode(1);        &#125;        return head;    &#125;&#125;;\n\n\n边界处理细节\n\n\n情况\n是否处理？\n说明\n\n\n\nl1 或 l2 为 nullptr\n✅\n使用三元运算符 (l1 ? l1-&gt;val : 0) 处理\n\n\n两链表长度不同\n✅\n遍历到最长链表结束即可\n\n\n最后一位有进位\n✅\nif (carry == 1) 添加尾部节点\n\n\n\n示例\n\n\nl1\nl2\n输出结果\n说明\n\n\n\n[2,4,3]\n[5,6,4]\n[7,0,8]\n342 + 465 &#x3D; 807\n\n\n[0]\n[0]\n[0]\n简单零值\n\n\n[9,9,9]\n[1]\n[0,0,0,1]\n999 + 1 &#x3D; 1000\n\n\n","slug":"LeetCode/LeetCode-2两数相加","date":"2025-07-20T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"ceb487e3836d4783d6609198e2dba7d6","title":"LeetCode-21合并两个有序链表","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode 21. Merge Two Sorted Lists\n题目描述给你两个 升序 链表 list1 和 list2，请将它们合并为一个新的 升序 链表，并返回新链表的头节点。\n\n解法一：迭代解题思路这道题的关键在于：两个链表已经是有序的，所以我们可以使用 双指针 + 逐步合并 的方式来构建一个新的有序链表。\n相比于常见的虚拟头节点解法，这段代码采用了原地合并 + 不额外创建节点 的策略，节省了空间。\n\n核心逻辑解析123if (list1 == nullptr || list2 == nullptr) &#123;    return list1 == nullptr ? list2 : list1;&#125;\n\n\n边界情况处理：如果有一个链表为空，直接返回另一个链表。\n\n1ListNode* head = list1-&gt;val &gt; list2-&gt;val ? list2 : list1;\n\n\n选出头结点：将两个链表中值较小的那个作为合并后链表的头。\n\n123ListNode* cur1 = head-&gt;next;ListNode* cur2 = (head == list1) ? list2 : list1;ListNode* pre = head;\n\n\n初始化指针：\ncur1 是当前主链表（较小值所在链表）后继；\ncur2 是另一个链表；\npre 记录新链表的构建位置。\n\n\n\n\n循环合并过程12345678910while (cur1 != nullptr &amp;&amp; cur2 != nullptr) &#123;    if (cur1-&gt;val &gt; cur2-&gt;val) &#123;        pre-&gt;next = cur2;        cur2 = cur2-&gt;next;    &#125; else &#123;        pre-&gt;next = cur1;        cur1 = cur1-&gt;next;    &#125;    pre = pre-&gt;next;&#125;\n\n\n每次将当前值较小的节点接到 pre 后，并移动相应指针。\n\n\n拼接剩余链表1pre-&gt;next = cur1 != nullptr ? cur1 : cur2;\n\n\n当有一个链表已经走完，直接将另一个剩下的部分接在后面。\n\n\n完整代码（C++）123456789101112131415161718192021222324252627class Solution &#123;public:    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;        if (list1 == nullptr || list2 == nullptr) &#123;            return list1 == nullptr ? list2 : list1;        &#125;        ListNode* head = list1-&gt;val &gt; list2-&gt;val ? list2 : list1;        ListNode* cur1 = head-&gt;next;        ListNode* cur2 = (head == list1) ? list2 : list1;        ListNode* pre = head;        while (cur1 != nullptr &amp;&amp; cur2 != nullptr) &#123;            if (cur1-&gt;val &gt; cur2-&gt;val) &#123;                pre-&gt;next = cur2;                cur2 = cur2-&gt;next;            &#125; else &#123;                pre-&gt;next = cur1;                cur1 = cur1-&gt;next;            &#125;            pre = pre-&gt;next;        &#125;        pre-&gt;next = cur1 != nullptr ? cur1 : cur2;        return head;    &#125;&#125;;\n\n\n小结这段代码技巧性强，不使用虚拟头节点，而是从一开始就选定一个较小节点作为 head，在效率和空间上都表现优秀\n","slug":"LeetCode/LeetCode-21合并两个有序链表","date":"2025-07-19T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"94d081a5c7789012b1a36e6503ab4408","title":"LeetCode-912排序数组","content":"\n\n\n\n\n\n\n\n\nLeetCode - 912. 排序数组\n题目描述：给你一个整数数组 nums，请你将该数组升序排列。你必须在 不使用任何内置函数 的情况下解决问题，时间复杂度为 O(n log n)，并且空间复杂度尽可能小。\n示例 1：\n\n\n\n\n\n\n\n\n\n输入： nums &#x3D; [5,2,3,1]输出： [1,2,3,5]\n示例 2：\n\n\n\n\n\n\n\n\n\n输入： nums &#x3D; [5,1,1,2,0,0]输出： [0,0,1,1,2,5]\n\n解法一：快速排序不了解快速排序的可以先看（快速排序（点击跳转））\n这道题要求我们对一个整数数组进行升序排序，并明确限制了不能使用内置排序函数，同时要求时间复杂度为 O(n log n)，空间复杂度尽可能小。快速排序 是满足这些要求的经典算法之一，尤其适合作为本题的解法。\n算法思想我们将采用 快速排序（Quick Sort） 算法，它是一种基于 分治 思想的高效排序算法，其核心步骤如下：\n\n分区 (Partition)：从数组中选择一个元素作为“基准”（pivot）。为了避免在数组已有序或近乎有序时出现 O(n²) 的最坏情况，我们 随机选择 一个基准。然后，重新排列数组，使得所有小于基准的元素都移动到基准的左边，所有大于等于基准的元素都移动到右边。操作结束后，该基准元素就位于其最终的有序位置。\n\n递归 (Recurse)：对基准左侧和右侧的两个子数组，递归地应用快速排序。\n\n终止条件：当子数组的长度为 0 或 1 时，它天然是有序的，递归结束。\n\n\n通过这种方式，一个大问题被不断地分解成小问题来解决，最终完成整个数组的排序。\n代码实现 (C++)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public:    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123;        // 初始化随机种子，以确保每次运行的随机性，避免最坏情况        srand(time(0));         quickSort(nums, 0, nums.size() - 1);        return nums;    &#125;private:    /**     * @brief 对数组 nums 的 [low, high] 区间进行快速排序     */    void quickSort(vector&lt;int&gt;&amp; nums, int low, int high) &#123;        // 终止条件：当子数组只有一个元素或为空时        if (low &gt;= high) &#123;            return;        &#125;        // 找到基准元素的正确位置        int pivotIndex = partition(nums, low, high);        // 递归地对基准左侧的子数组进行排序        quickSort(nums, low, pivotIndex - 1);        // 递归地对基准右侧的子数组进行排序        quickSort(nums, pivotIndex + 1, high);    &#125;    /**     * @brief 分区操作，并返回基准元素的最终索引     */    int partition(vector&lt;int&gt;&amp; nums, int low, int high) &#123;        // 1. 随机选择一个基准，并将其与区间的最后一个元素交换        //    这样做可以有效避免最坏情况的发生        int randomIndex = low + rand() % (high - low + 1);        swap(nums[randomIndex], nums[high]);                int pivot = nums[high]; // 将最后一个元素作为基准        int i = low; // i 指向下一个小于基准的元素应该存放的位置        // 2. 遍历数组，将小于基准的元素移动到 i 指针的左侧        for (int j = low; j &lt; high; j++) &#123;            if (nums[j] &lt; pivot) &#123;                swap(nums[i], nums[j]);                i++;            &#125;        &#125;                // 3. 将基准元素放到它的最终位置 (i)        swap(nums[i], nums[high]);                return i; // 返回基准元素的索引    &#125;&#125;;\n\n","slug":"LeetCode/LeetCode-912排序数组","date":"2025-07-18T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"dea48bae008655416810ebc549cb2ffd","title":"冒泡排序（Bubble Sort）","content":"冒泡排序（Bubble Sort）冒泡排序是一种简单直观的排序算法。它重复地遍历待排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n一、算法原理1.1 核心思想冒泡排序的核心在于重复地比较并交换相邻元素。它会遍历整个数组，每次比较相邻的两个元素，如果它们的顺序不正确（例如，前者大于后者），就将它们交换。通过这样一轮轮的遍历，每一轮都会将当前未排序部分中的最大（或最小）元素“冒泡”到其最终位置。\n1.2 详细步骤\n比较与交换：从数组的第一个元素开始，比较它与下一个元素的大小。如果顺序错误，则交换它们。\n向后移动：将比较窗口向后移动一位，继续比较下一对相邻元素，重复此过程直到数组末尾。\n完成一轮：当完成从头到尾的一轮遍历后，数组中最大的元素会被放置在最后一个位置。\n缩小范围：忽略已经排好序的最后一个元素，对前面的 n-1 个元素重复以上步骤。\n终止条件：持续这个过程，直到整个数组排序完成。\n\n1.3 示例演示以数组 [6, 4, 7, 2, 9] 为例，排序过程如下：\n\n\n\n轮次\n过程描述\n数组状态\n\n\n\n第1轮\n6&gt;4交换, 6&lt;7不换, 7&gt;2交换, 7&lt;9不换\n[4, 6, 2, 7, **9**]\n\n\n第2轮\n4&lt;6不换, 6&gt;2交换, 6&lt;7不换\n[4, 2, 6, **7**, 9]\n\n\n第3轮\n4&gt;2交换, 4&lt;6不换\n[2, 4, **6**, 7, 9]\n\n\n第4轮\n2&lt;4不换\n[**2**, 4, 6, 7, 9]\n\n\n\n二、性能与特点2.1 复杂度分析\n时间复杂度\n最佳情况：O(n) - 当数组几乎有序时，优化后的算法只需一轮遍历。\n平均情况：O(n²)\n最坏情况：O(n²) - 当数组完全逆序时。\n\n\n空间复杂度：O(1) - 属于原地排序，仅需常数级别的额外空间。\n稳定性：稳定。因为只有当前元素严格大于后一个元素时才交换，相等元素的相对顺序不会改变。\n\n2.2 优缺点\n\n\n优点\n缺点\n\n\n\n实现简单，代码易于理解\n效率低下，不适合大规模数据\n\n\n稳定性好，保留相等元素顺序\n比较和交换次数过多\n\n\n空间占用少，是原地排序算法\n性能远不如快速排序、归并排序等\n\n\n2.3 适用场景\n教学演示：作为入门级排序算法，非常适合教学。\n小规模数据：当待排序的元素数量很少时（例如 n &lt; 20），其简单性可能优于复杂算法的设置开销。\n几乎有序的数组：优化后的冒泡排序在这种情况下效率很高。\n\n\n三、代码实现与优化(以下代码默认 using namespace std;)\n3.1 基础版本 (C++)1234567891011// 基础冒泡排序void bubbleSort(int arr[], int n) &#123;    for (int i = 0; i &lt; n - 1; i++) &#123;        // 每轮将一个最大值放到末尾        for (int j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr[j], arr[j + 1]);            &#125;        &#125;    &#125;&#125;\n\n3.2 优化版本 (C++)通过增加一个标志位，可以检测数组是否已经提前有序，从而避免不必要的遍历。\n12345678910111213141516// 优化版冒泡排序void optimizedBubbleSort(int arr[], int n) &#123;    for (int i = 0; i &lt; n - 1; i++) &#123;        bool swapped = false; // 交换标志位        for (int j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr[j], arr[j + 1]);                swapped = true;            &#125;        &#125;        // 如果在一轮遍历中没有发生交换，说明数组已有序        if (!swapped) &#123;            break;        &#125;    &#125;&#125;\n\n3.3 拓展：鸡尾酒排序鸡尾酒排序（Cocktail Shaker Sort）是冒泡排序的变体，它通过双向遍历来提升性能，既从左到右“冒泡”最大值，也从右到左“冒泡”最小值。\n1234567891011121314151617181920212223242526272829// 鸡尾酒排序void cocktailSort(int arr[], int n) &#123;    bool swapped = true;    int start = 0;    int end = n - 1;    while (swapped) &#123;        swapped = false;        // 从左到右，将最大值移动到末尾        for (int i = start; i &lt; end; ++i) &#123;            if (arr[i] &gt; arr[i + 1]) &#123;                swap(arr[i], arr[i + 1]);                swapped = true;            &#125;        &#125;        if (!swapped) break;        --end;        swapped = false;        // 从右到左，将最小值移动到开头        for (int i = end - 1; i &gt;= start; --i) &#123;            if (arr[i] &gt; arr[i + 1]) &#123;                swap(arr[i], arr[i + 1]);                swapped = true;            &#125;        &#125;        ++start;    &#125;&#125;\n\n\n四、知识检验4.1 测验题\n冒泡排序的平均时间复杂度是多少？\n为什么说冒泡排序是稳定的？\n对于一个已经完全排好序的数组，优化版的冒泡排序时间复杂度是多少？\n冒泡排序每一轮遍历结束后，能确定哪个元素的位置？\n除了设置标志位提前终止，还有其他优化冒泡排序的思路吗？\n\n4.2 测验答案\n平均时间复杂度是 O(n²)。\n因为只有当前一个元素严格大于后一个元素时才进行交换，相等元素之间的相对顺序不会改变。\n时间复杂度为 O(n)，因为它只需要完整遍历一次，发现没有发生任何元素交换后就会提前退出。\n每一轮结束后，都能确定当前未排序部分的最大元素的位置，并将其置于该部分的末尾。\n可以记录最后一次发生交换的位置，下一轮遍历时只需扫描到该位置即可，因为之后的部分已经是有序的了。\n\n\n五、练习与拓展5.1 推荐练习题 (LeetCode)\n\n\n推荐题目\n我的题解\n\n\n\n75. 颜色分类\n暂未完成\n\n\n283. 移动零\n暂未完成\n\n\n912. 排序数组\n暂未完成\n\n\n\n\n\n\n\n\n\n\n\n注意：虽然冒泡排序可以解决以上问题，但通常不是时间复杂度最优的解法，这些题目更适合用于加深对排序思想的理解。\n\n本文旨在帮助初学者理解冒泡排序的核心思想及应用，欢迎收藏和分享。\n","slug":"AlgorithmsDataStructures/排序算法/冒泡排序","date":"2025-07-18T04:00:00.000Z","categories_index":"算法与数据结构,排序算法","tags_index":"排序","author_index":"Random"},{"id":"128d5f401a6627e4435b6e43e76ac072","title":"快速排序（Quick Sort）","content":"快速排序（Quick Sort）快速排序（Quick Sort）是一种极其高效的分治排序算法，也是实际应用中最常用的排序算法之一。它通过选择一个“基准”元素，将数组划分为两个子数组——一部分小于基准，另一部分大于基准，然后对这两个子数组递归地进行排序，最终使整个数组有序。\n\n一、算法原理1.1 核心思想快速排序的核心可以概括为“选个基准，然后左右站队”：\n\n选择基准 (Pivot)：从数组中任意选择一个元素作为“基准”。\n分区 (Partitioning)：重新排列数组，将所有小于基准的元素移动到基准的左边，所有大于或等于基准的元素移动到右边。完成这一步后，该基准元素就找到了它在最终有序序列中的正确位置。\n分而治之 (Divide and Conquer)：对基准左右两边的子数组（现在是两个独立的、更小的问题）递归地重复上述过程，直到每个子数组都排序完毕。\n\n1.2 详细步骤\n从数列中选择一个元素作为“基准”（本文示例采用最左侧元素）。\n执行分区操作：将所有比基准值小的元素放到基准前面，所有比基准值大的元素放到基准后面。\n对基准左右两个子序列分别重复步骤1和2，直到子序列只有一个元素或为空。\n\n1.3 示例演示以数组 [10, 7, 8, 9, 1, 5] 为例，排序过程如下（以最左侧元素为基准）：\n\n\n\n轮次\n操作描述\n当前数组状态\n\n\n\n第1轮\n初始数组: [10, 7, 8, 9, 1, 5]  选择基准: 10  分区结果: 将小于10的元素移到左侧\n[5, 7, 8, 9, 1, **10**]\n\n\n第2轮 (处理左子数组)\n当前子数组: [5, 7, 8, 9, 1]  选择基准: 5  分区结果: 将小于5的元素1移到左侧\n[1, **5**, 8, 9, 7]\n\n\n第3轮 (处理右子数组)\n当前子数组: [8, 9, 7]  选择基准: 8  分区结果: 将小于8的元素7移到左侧\n[1, 5, **7**, **8**, 9]\n\n\n完成\n所有子数组处理完毕，数组整体有序\n[1, 5, 7, 8, 9, 10]\n\n\n\n二、性能与特点2.1 复杂度分析\n时间复杂度\n最佳情况：O(n log n)\n平均情况：O(n log n)\n最坏情况：O(n²) - 当数组已排序或接近排序，且基准选择不佳时。\n\n\n空间复杂度：O(log n) - 主要用于递归调用的栈空间。\n稳定性：不稳定。因为分区过程中，相等元素的原始相对顺序可能会被改变。\n\n2.2 优缺点\n\n\n优点\n缺点\n\n\n\n平均效率高，是实际应用中最快的排序算法之一\n最坏情况性能差，时间复杂度退化至 O(n²)\n\n\n原地排序，空间复杂度低 (O(log n))\n不稳定的排序算法\n\n\n缓存友好，数据局部性好，访问模式高效\n对小数组不占优，可能比插入排序等更慢\n\n\n2.3 适用场景\n需要高效排序大量数据的场景。\n作为许多标准库（如C++ std::sort）的内部实现。\n对空间复杂度敏感，需要原地排序的应用。\n当不要求排序必须是稳定的时候。\n\n\n三、代码实现与优化(以下代码默认 using namespace std;)\n3.1 基础版本 (C++)1234567891011121314151617181920212223242526// 分区操作int partition(int arr[], int low, int high) &#123;    // 选择最左侧元素作为基准    int pivot = arr[low];    int i = low;    for (int j = low + 1; j &lt;= high; j++) &#123;        if (arr[j] &lt; pivot) &#123;            i++;            swap(arr[i], arr[j]);        &#125;    &#125;    // 将基准元素放到正确位置    swap(arr[low], arr[i]);    return i;&#125;// 快速排序主函数void quickSort(int arr[], int low, int high) &#123;    if (low &lt; high) &#123;        int pivotIndex = partition(arr, low, high);        // 递归排序左右子数组        quickSort(arr, low, pivotIndex - 1);        quickSort(arr, pivotIndex + 1, high);    &#125;&#125;\n\n3.2 优化策略 (C++)1. 随机化基准为避免在有序或近乎有序的数组上性能退化，可以随机选择一个元素作为基准。\n12345678// 随机化分区int randomPartition(int arr[], int low, int high) &#123;    // 随机选择一个基准，并与最左侧元素交换    srand(time(NULL));    int randomIndex = low + rand() % (high - low + 1);    swap(arr[randomIndex], arr[low]);    return partition(arr, low, high);&#125;\n\n2. 三数取中法选择数组的左端、中间和右端三个元素的中位数作为基准，可以更有效地避免最坏情况。\n12345678910111213141516// 三数取中获取基准并放到low位置void medianOfThree(int arr[], int low, int high) &#123;    int mid = low + (high - low) / 2;    if (arr[mid] &lt; arr[low]) swap(arr[mid], arr[low]);    if (arr[high] &lt; arr[low]) swap(arr[high], arr[low]);    if (arr[mid] &lt; arr[high]) swap(arr[mid], arr[low]); // 将中值放到low&#125;void quickSortWithMedian(int arr[], int low, int high) &#123;    if (low &lt; high) &#123;        medianOfThree(arr, low, high);        int pivotIndex = partition(arr, low, high);        quickSortWithMedian(arr, low, pivotIndex - 1);        quickSortWithMedian(arr, pivotIndex + 1, high);    &#125;&#125;\n\n\n四、知识检验4.1 测验题\n快速排序的平均时间复杂度是多少？\n快速排序是稳定的排序算法吗？为什么？\n使用最左侧元素作为基准的快速排序在什么情况下会出现最坏性能？\n快速排序的空间复杂度是多少？它主要由什么产生？\n\n4.2 测验答案\nO(n log n)。\n不是。因为在分区过程中，与基准相等的元素的相对位置可能会因为交换而改变。\n当数组已经排序或完全逆序时。此时每次分区都非常不平衡，导致递归树深度为 O(n)。\nO(log n)。它主要由递归调用产生的函数调用栈空间所决定。最坏情况下空间复杂度会达到 O(n)。\n\n\n五、练习与拓展5.1 推荐练习题 (LeetCode)\n\n\n推荐题目\n我的题解\n\n\n\n215. 数组中的第K个最大元素\n暂未完成\n\n\n912. 排序数组\n暂未完成\n\n\n75. 颜色分类\n暂未完成\n\n\n\n\n\n\n\n\n\n\n\n注意：虽然快速排序可以解决以上问题，但理解其核心的分区思想对于解决这类问题至关重要，不一定需要完整实现排序。\n\n本文旨在帮助初学者理解快速排序的核心思想及应用，欢迎收藏和分享。\n","slug":"AlgorithmsDataStructures/排序算法/快速排序","date":"2025-07-18T04:00:00.000Z","categories_index":"算法与数据结构,排序算法","tags_index":"排序","author_index":"Random"},{"id":"f01cc273b0b1b737816c95524ea0b79c","title":"LeetCode-2367等差三元组的数目","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode - 2367.Number of Arithmetic Triplets\n解法一：三指针题目描述给定一个严格递增的整数数组 nums 和一个正整数 diff，请统计满足以下条件的三元组 (i, j, k) 的数量：\n\n三个下标满足：i &lt; j &lt; k\n数组元素满足：nums[j] - nums[i] == diff 且 nums[k] - nums[j] == diff\n\n换句话说，就是寻找等差数列长度为 3 的子序列个数，且公差为 diff。\n\n问题分析\n输入数组 nums 是严格递增的，这意味着 nums[i] &lt; nums[j] &lt; nums[k] 对于所有 i &lt; j &lt; k 都成立。\n题目核心就是寻找满足 nums[j] = nums[i] + diff 且 nums[k] = nums[j] + diff 的三元组。\n简单的暴力解法是三重循环枚举所有 (i, j, k)，时间复杂度为 O(n³)，在数据量较大时会超时。\n如何利用数组的有序特性，优化搜索过程？\n\n解题思路\n使用三个指针 i, j, k 分别表示三元组的三个位置。\n指针初始设置为：i = 0, j = 1, k = 2。\n固定 k 从索引 2 开始遍历，表示当前考察的三元组末尾元素。\n利用数组有序的特性，调整 j 和 i 指针使其满足：\nnums[j] + diff == nums[k]\nnums[i] + diff == nums[j]\n\n\n如果满足条件，则计数增加。\n指针只会向前移动，不回退，保证了时间复杂度为 O(n)。\n\n具体步骤\n对于每个 k（从 2 开始）：\n移动 j，使得 nums[j] + diff &gt;= nums[k]。\n如果 nums[j] + diff &gt; nums[k]，则该 k 不满足条件，跳过。\n否则，移动 i，使得 nums[i] + diff &gt;= nums[j]。\n如果 nums[i] + diff == nums[j]，说明找到一个满足条件的三元组，计数加 1。\n\n\n\n1234567891011121314151617181920class Solution &#123;public:    int arithmeticTriplets(vector&lt;int&gt;&amp; nums, int diff) &#123;        int i = 0, j = 1, ans = 0;        for (int k = 2; k &lt; nums.size(); k++) &#123;            // 移动j指针，直到 nums[j] + diff &gt;= nums[k]            while (j &lt; k &amp;&amp; nums[j] + diff &lt; nums[k]) ++j;            // 如果 nums[j] + diff 不等于 nums[k]，继续下一个 k            if (j == k || nums[j] + diff &gt; nums[k]) continue;            // 移动i指针，直到 nums[i] + diff &gt;= nums[j]            while (i &lt; j &amp;&amp; nums[i] + diff &lt; nums[j]) ++i;            // 如果 nums[i] + diff 等于 nums[j]，说明找到一个等差三元组            if (i &lt; j &amp;&amp; nums[i] + diff == nums[j]) ans++;        &#125;        return ans;    &#125;&#125;;\n\n解法二：哈希表\n由于数组严格递增，也可以使用哈希集合保存所有元素。\n遍历数组元素 num，判断 num + diff 和 num + 2 * diff 是否存在。\n这种方法代码更简洁，时间复杂度仍为 O(n)，空间换时间。\n\n示例代码：\n12345678910111213class Solution &#123;public:    int arithmeticTriplets(vector&lt;int&gt;&amp; nums, int diff) &#123;        unordered_set&lt;int&gt; s(nums.begin(), nums.end());        int ans = 0;        for (int num : nums) &#123;            if (s.count(num + diff) &amp;&amp; s.count(num + 2 * diff)) &#123;                ans++;            &#125;        &#125;        return ans;    &#125;&#125;;\n\n对比双指针和哈希法\n双指针方法不需要额外空间，适合对空间敏感的场景。\n哈希方法代码更简洁，查找速度快，但需额外空间。\n选择合适的方法依据具体场景和数据规模。\n\n","slug":"LeetCode/LeetCode-2367等差三元组的数目","date":"2025-07-17T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"50923e38d6714eed297b6e077bc9df21","title":"LeetCode-42接雨水","content":"\n\n\n\n\n\n\n\n\n题目链接：LeetCode - 42. Trapping Rain Water\n解法一：相向双指针题目思路：双指针法 + 局部最值本题的目标是，给定一个整数数组 height，其中每个元素代表一个单位宽度的柱子的高度，求这些柱子可以接住多少单位的雨水。\n算法核心思想：我们使用 双指针法 从两边向中间遍历，同时记录当前左右的最大高度 tL 和 rL。每次比较左右最大值，谁小就移动谁的指针，这样可以确保当前指针所处位置可以接的雨水只依赖于较小的一边。\n定义：\nl, r: 左右指针，初始指向数组两端。\ntL, rL: 当前指针左侧和右侧的最大高度。\nans: 最终答案，即累计接住的雨水量。\n\n1234567891011121314151617181920212223242526class Solution &#123;public:\tint trap(vector&lt;int&gt;&amp; height) &#123;\t    int n = height.size();        // 柱子的总数\t    int l = 0, r = n - 1;         // 左右指针\t    int tL = 0, rL = 0;           // 左右的最高柱子\t    int ans = 0;                  // 接住的雨水总量\t    \t    while (l &lt; r) &#123;\t        // 更新左右最大高度\t        tL = max(tL, height[l]);\t        rL = max(rL, height[r]);\t        // 谁的最大高度更小，就看谁那边能不能接水\t        if (tL &lt; rL) &#123;\t            ans += tL - height[l];  // 左边接水 = 左最大高度 - 当前高度\t            l++;                    // 移动左指针\t        &#125; else &#123;\t            ans += rL - height[r];  // 右边接水 = 右最大高度 - 当前高度\t            r--;                    // 移动右指针\t        &#125;\t    &#125;\t\t    return ans;\t&#125;&#125;;\n\n\n\n示例分析：输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6\n解释：\n接水的区域如下图所示（柱状图视角）：\n123    █ █   █ ██ █ ███\n\n接水量：1 + 1 + 2 + 1 + 1 = 6\n","slug":"LeetCode/LeetCode-42接雨水","date":"2025-07-16T08:00:00.000Z","categories_index":"","tags_index":"LeetCode","author_index":"Random"},{"id":"ffcfdc2657e27f0f1d5678cd568c11ab","title":"算法复杂度一览表","content":"时间空间复杂度常见情况🧊时间\n\n\n名称\n记号\n说明\n典型例子\n\n\n\n常数阶\nO(1)\n不随输入规模变化\n访问数组某个元素\n\n\n对数阶\nO(log n)\n输入每次减半\n二分查找、平衡二叉搜索树操作\n\n\n线性阶\nO(n)\n遍历整个输入\n顺序查找、遍历数组\n\n\n线性对数阶\nO(n log n)\n分治递归 + 遍历\n快排、归并排序、堆排序\n\n\n平方阶\nO(n²)\n嵌套两层循环\n冒泡排序、选择排序、插入排序\n\n\n立方阶\nO(n³)\n三层嵌套循环\nFloyd 最短路径\n\n\n指数阶\nO(2ⁿ)\n枚举所有组合\n子集生成、背包问题暴力递归\n\n\n阶乘阶\nO(n!)\n全排列枚举\n旅行商问题暴力解、n皇后问题\n\n\n🧊 空间\n\n\n空间复杂度\n示例\n\n\n\nO(1)\n原地排序、双指针、滑动窗口\n\n\nO(n)\n需要额外数组、哈希表、栈、队列\n\n\nO(n²)\n二维矩阵（如图算法、DP表）\n\n\n💡 小技巧：估算能不能过\n\n\n输入规模 n\n推荐算法复杂度上限\n\n\n\nn ≤ 10\nO(n!) 可接受\n\n\nn ≤ 20\nO(2ⁿ) 可接受\n\n\nn ≤ 1e2\nO(n³) 可接受\n\n\nn ≤ 1e4\nO(n²) 可接受\n\n\nn ≤ 1e5\nO(n log n) 必须\n\n\nn ≤ 1e6\nO(n) 最佳\n\n\n\n算法与数据结构复杂度一览表本表系统整理了算法复杂度的核心概念及常见算法&#x2F;数据结构在时间和空间复杂度上的表现，便于查阅和对比。\n\n一、什么是算法复杂度？算法复杂度是衡量算法性能的重要指标，主要包括时间复杂度（执行所需时间）和空间复杂度（所需内存），常用**大O表示法（Big O Notation）**描述在最坏情况下的上界。\n\n二、常见时间复杂度和空间复杂度\n\n\n表达式\n名称\n举例\n\n\n\nO(1)\n常数\n数组访问、哈希查找\n\n\nO(log n)\n对数\n二分查找\n\n\nO(n)\n线性\n遍历数组\n\n\nO(n log n)\n线性对数\n归并排序、快速排序\n\n\nO(n²)\n平方\n冒泡排序、插入排序\n\n\nO(2ⁿ)\n指数\n递归斐波那契、子集生成\n\n\nO(n!)\n阶乘\n全排列问题\n\n\n\n三、排序算法复杂度\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n冒泡排序\nO(n)\nO(n²)\nO(n²)\nO(1)\n\n\n选择排序\nO(n²)\nO(n²)\nO(n²)\nO(1)\n\n\n插入排序\nO(n)\nO(n²)\nO(n²)\nO(1)\n\n\n归并排序\nO(n log n)\nO(n log n)\nO(n log n)\nO(n)\n\n\n快速排序\nO(n log n)\nO(n log n)\nO(n²)\nO(log n)\n\n\n堆排序\nO(n log n)\nO(n log n)\nO(n log n)\nO(1)\n\n\n计数排序\nO(n + k)\nO(n + k)\nO(n + k)\nO(n + k)\n\n\n基数排序\nO(nk)\nO(nk)\nO(nk)\nO(n + k)\n\n\n桶排序\nO(n)\nO(n + k)\nO(n²)\nO(n + k)\n\n\n希尔排序\nO(n log n)\nO(n log² n)\nO(n²)\nO(1)\n\n\n\n四、查找算法复杂度\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n线性查找\nO(1)\nO(n)\nO(n)\nO(1)\n\n\n二分查找\nO(1)\nO(log n)\nO(log n)\nO(1)\n\n\n跳跃查找\nO(1)\nO(√n)\nO(√n)\nO(1)\n\n\n插值查找\nO(1)\nO(log log n)\nO(n)\nO(1)\n\n\n哈希查找\nO(1)\nO(1)\nO(n)\nO(n)\n\n\n\n五、线性数据结构复杂度\n\n\n结构&#x2F;操作\n最佳\n平均\n最差\n空间复杂度\n\n\n\n数组-访问\nO(1)\nO(1)\nO(1)\nO(1)\n\n\n数组-插入&#x2F;删除\nO(1)\nO(n)\nO(n)\nO(1)\n\n\n链表-访问\nO(1)\nO(n)\nO(n)\nO(1)\n\n\n链表-插入&#x2F;删除\nO(1)\nO(1)\nO(1)\nO(1)\n\n\n栈&#x2F;队列-操作\nO(1)\nO(1)\nO(1)\nO(1)\n\n\n\n六、树形数据结构复杂度\n\n\n结构&#x2F;操作\n最佳\n平均\n最差\n空间复杂度\n\n\n\n二叉搜索树-查找\nO(log n)\nO(log n)\nO(n)\nO(1)\n\n\nAVL树&#x2F;红黑树\nO(log n)\nO(log n)\nO(log n)\nO(n)\n\n\n堆-操作\nO(1)\nO(log n)\nO(log n)\nO(1)\n\n\nTrie树-操作\nO(m)\nO(m)\nO(m)\nO(nm)\n\n\n\n七、图形数据结构复杂度\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n邻接矩阵 - 访问&#x2F;搜索&#x2F;插入&#x2F;删除\nO(1)\nO(1)\nO(1)\nO(V²)\n\n\n邻接矩阵 - 遍历\nO(V²)\nO(V²)\nO(V²)\nO(V²)\n\n\n邻接表 - 访问\nO(1)\nO(1)\nO(V)\nO(V+E)\n\n\n邻接表 - 搜索\nO(1)\nO(V)\nO(V)\nO(V+E)\n\n\n邻接表 - 插入\nO(1)\nO(1)\nO(1)\nO(V+E)\n\n\n邻接表 - 删除\nO(1)\nO(E)\nO(E)\nO(V+E)\n\n\n邻接表 - 遍历\nO(V+E)\nO(V+E)\nO(V+E)\nO(V+E)\n\n\n边列表 - 访问&#x2F;搜索\nO(1)\nO(E)\nO(E)\nO(E)\n\n\n边列表 - 插入&#x2F;删除\nO(1)\nO(1)\nO(1)\nO(E)\n\n\n边列表 - 遍历\nO(E)\nO(E)\nO(E)\nO(E)\n\n\n有向&#x2F;无向&#x2F;加权图-基本操作\nO(1)\nO(V+E)\nO(V+E)\nO(V+E)\n\n\n有向无环图(DAG)-基本操作\nO(1)\nO(V+E)\nO(V+E)\nO(V+E)\n\n\n\n\n\n\n\n\n\n\n\n注：V为顶点数，E为边数。\n\n八、哈希与映射\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n哈希表-操作\nO(1)\nO(1)\nO(n)\nO(n)\n\n\n布隆过滤器\nO(k)\nO(k)\nO(k)\nO(m)\n\n\n\n九、高级数据结构\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n并查集\nO(1)\nO(α(n))\nO(α(n))\nO(n)\n\n\n跳表\nO(log n)\nO(log n)\nO(n)\nO(n)\n\n\n\n十、图论算法\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\nBFS&#x2F;DFS\nO(V+E)\nO(V+E)\nO(V+E)\nO(V)\n\n\nDijkstra\nO(V²+E)\nO(V²+E)\nO(V²+E)\nO(V)\n\n\nBellman-Ford\nO(VE)\nO(VE)\nO(VE)\nO(V)\n\n\nFloyd-Warshall\nO(V³)\nO(V³)\nO(V³)\nO(V²)\n\n\nKruskal\nO(E log E)\nO(E log E)\nO(E log E)\nO(V+E)\n\n\nPrim\nO(E log V)\nO(E log V)\nO(E log V)\nO(V)\n\n\n拓扑排序\nO(V+E)\nO(V+E)\nO(V+E)\nO(V)\n\n\n\n十一、字符串和数论算法字符串算法\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\nKMP算法\nO(n)\nO(m+n)\nO(m+n)\nO(m)\n\n\nRabin-Karp算法\nO(n)\nO(m+n)\nO(mn)\nO(1)\n\n\nBoyer-Moore算法\nO(n&#x2F;m)\nO(n)\nO(mn)\nO(m)\n\n\n数论算法\n\n\n算法名称\n最佳\n平均\n最差\n空间复杂度\n\n\n\n欧几里得算法(GCD)\nO(1)\nO(log min(a,b))\nO(log min(a,b))\nO(1)\n\n\n快速幂\nO(log n)\nO(log n)\nO(log n)\nO(1)\n\n\n埃拉托斯特尼筛法\nO(n log log n)\nO(n log log n)\nO(n log log n)\nO(n)\n\n\n模逆元计算\nO(n³)\nO(n³)\nO(n³)\nO(n²)\n\n\n\n十二、复杂度分析与算法选择建议\n根据输入数据规模、时间效率要求、内存限制等选取算法；\n合理利用空间换时间、分治、动态规划等优化策略；\n选择适合场景的数据结构（如查找优先用哈希&#x2F;二分查找，稀疏图用邻接表等）。\n\n\n\n\n\n\n\n\n\n\n\n本表仅供速查，实际复杂度可能因具体实现、输入分布和硬件环境而有所不同。\n","slug":"AlgorithmsDataStructures/其他/算法复杂度一览表","date":"2025-07-14T16:00:00.000Z","categories_index":"算法与数据结构","tags_index":"","author_index":"Random"}]