{"title":"快速排序（Quick Sort）","uid":"128d5f401a6627e4435b6e43e76ac072","slug":"AlgorithmsDataStructures/排序算法/快速排序","date":"2025-07-18T04:00:00.000Z","updated":"2025-07-28T13:30:30.656Z","comments":true,"path":"api/articles/AlgorithmsDataStructures/排序算法/快速排序.json","keywords":null,"cover":null,"content":"<h1 id=\"快速排序（Quick-Sort）\"><a href=\"#快速排序（Quick-Sort）\" class=\"headerlink\" title=\"快速排序（Quick Sort）\"></a>快速排序（Quick Sort）</h1><p>快速排序（Quick Sort）是一种极其高效的分治排序算法，也是实际应用中最常用的排序算法之一。它通过选择一个“基准”元素，将数组划分为两个子数组——一部分小于基准，另一部分大于基准，然后对这两个子数组递归地进行排序，最终使整个数组有序。</p>\n<hr>\n<h2 id=\"一、算法原理\"><a href=\"#一、算法原理\" class=\"headerlink\" title=\"一、算法原理\"></a>一、算法原理</h2><h3 id=\"1-1-核心思想\"><a href=\"#1-1-核心思想\" class=\"headerlink\" title=\"1.1 核心思想\"></a>1.1 核心思想</h3><p>快速排序的核心可以概括为“选个基准，然后左右站队”：</p>\n<ol>\n<li><strong>选择基准 (Pivot)</strong>：从数组中任意选择一个元素作为“基准”。</li>\n<li><strong>分区 (Partitioning)</strong>：重新排列数组，将所有小于基准的元素移动到基准的左边，所有大于或等于基准的元素移动到右边。完成这一步后，该基准元素就找到了它在最终有序序列中的正确位置。</li>\n<li><strong>分而治之 (Divide and Conquer)</strong>：对基准左右两边的子数组（现在是两个独立的、更小的问题）递归地重复上述过程，直到每个子数组都排序完毕。</li>\n</ol>\n<h3 id=\"1-2-详细步骤\"><a href=\"#1-2-详细步骤\" class=\"headerlink\" title=\"1.2 详细步骤\"></a>1.2 详细步骤</h3><ol>\n<li>从数列中选择一个元素作为“基准”（本文示例采用最左侧元素）。</li>\n<li>执行分区操作：将所有比基准值小的元素放到基准前面，所有比基准值大的元素放到基准后面。</li>\n<li>对基准左右两个子序列分别重复步骤1和2，直到子序列只有一个元素或为空。</li>\n</ol>\n<h3 id=\"1-3-示例演示\"><a href=\"#1-3-示例演示\" class=\"headerlink\" title=\"1.3 示例演示\"></a>1.3 示例演示</h3><p>以数组 <code>[10, 7, 8, 9, 1, 5]</code> 为例，排序过程如下（以最左侧元素为基准）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">轮次</th>\n<th align=\"left\">操作描述</th>\n<th align=\"left\">当前数组状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>第1轮</strong></td>\n<td align=\"left\"><strong>初始数组</strong>: <code>[10, 7, 8, 9, 1, 5]</code> <br> <strong>选择基准</strong>: <code>10</code> <br> <strong>分区结果</strong>: 将小于<code>10</code>的元素移到左侧</td>\n<td align=\"left\"><code>[5, 7, 8, 9, 1, **10**]</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>第2轮 (处理左子数组)</strong></td>\n<td align=\"left\"><strong>当前子数组</strong>: <code>[5, 7, 8, 9, 1]</code> <br> <strong>选择基准</strong>: <code>5</code> <br> <strong>分区结果</strong>: 将小于<code>5</code>的元素<code>1</code>移到左侧</td>\n<td align=\"left\"><code>[1, **5**, 8, 9, 7]</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>第3轮 (处理右子数组)</strong></td>\n<td align=\"left\"><strong>当前子数组</strong>: <code>[8, 9, 7]</code> <br> <strong>选择基准</strong>: <code>8</code> <br> <strong>分区结果</strong>: 将小于<code>8</code>的元素<code>7</code>移到左侧</td>\n<td align=\"left\"><code>[1, 5, **7**, **8**, 9]</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>完成</strong></td>\n<td align=\"left\">所有子数组处理完毕，数组整体有序</td>\n<td align=\"left\"><code>[1, 5, 7, 8, 9, 10]</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"二、性能与特点\"><a href=\"#二、性能与特点\" class=\"headerlink\" title=\"二、性能与特点\"></a>二、性能与特点</h2><h3 id=\"2-1-复杂度分析\"><a href=\"#2-1-复杂度分析\" class=\"headerlink\" title=\"2.1 复杂度分析\"></a>2.1 复杂度分析</h3><ul>\n<li><strong>时间复杂度</strong><ul>\n<li>最佳情况：O(n log n)</li>\n<li>平均情况：O(n log n)</li>\n<li>最坏情况：O(n²) - 当数组已排序或接近排序，且基准选择不佳时。</li>\n</ul>\n</li>\n<li><strong>空间复杂度</strong>：O(log n) - 主要用于递归调用的栈空间。</li>\n<li><strong>稳定性</strong>：<strong>不稳定</strong>。因为分区过程中，相等元素的原始相对顺序可能会被改变。</li>\n</ul>\n<h3 id=\"2-2-优缺点\"><a href=\"#2-2-优缺点\" class=\"headerlink\" title=\"2.2 优缺点\"></a>2.2 优缺点</h3><table>\n<thead>\n<tr>\n<th align=\"left\">优点</th>\n<th align=\"left\">缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>平均效率高</strong>，是实际应用中最快的排序算法之一</td>\n<td align=\"left\"><strong>最坏情况性能差</strong>，时间复杂度退化至 O(n²)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>原地排序</strong>，空间复杂度低 (O(log n))</td>\n<td align=\"left\"><strong>不稳定</strong>的排序算法</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>缓存友好</strong>，数据局部性好，访问模式高效</td>\n<td align=\"left\"><strong>对小数组不占优</strong>，可能比插入排序等更慢</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-适用场景\"><a href=\"#2-3-适用场景\" class=\"headerlink\" title=\"2.3 适用场景\"></a>2.3 适用场景</h3><ul>\n<li>需要高效排序大量数据的场景。</li>\n<li>作为许多标准库（如C++ <code>std::sort</code>）的内部实现。</li>\n<li>对空间复杂度敏感，需要原地排序的应用。</li>\n<li>当不要求排序必须是稳定的时候。</li>\n</ul>\n<hr>\n<h2 id=\"三、代码实现与优化\"><a href=\"#三、代码实现与优化\" class=\"headerlink\" title=\"三、代码实现与优化\"></a>三、代码实现与优化</h2><p><em>(以下代码默认 <code>using namespace std;</code>)</em></p>\n<h3 id=\"3-1-基础版本-C\"><a href=\"#3-1-基础版本-C\" class=\"headerlink\" title=\"3.1 基础版本 (C++)\"></a>3.1 基础版本 (C++)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分区操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 选择最左侧元素作为基准</span></span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = arr[low];</span><br><span class=\"line\">    <span class=\"type\">int</span> i = low;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = low + <span class=\"number\">1</span>; j &lt;= high; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(arr[i], arr[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将基准元素放到正确位置</span></span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(arr[low], arr[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 快速排序主函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &lt; high) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> pivotIndex = <span class=\"built_in\">partition</span>(arr, low, high);</span><br><span class=\"line\">        <span class=\"comment\">// 递归排序左右子数组</span></span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(arr, low, pivotIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(arr, pivotIndex + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-优化策略-C\"><a href=\"#3-2-优化策略-C\" class=\"headerlink\" title=\"3.2 优化策略 (C++)\"></a>3.2 优化策略 (C++)</h3><h4 id=\"1-随机化基准\"><a href=\"#1-随机化基准\" class=\"headerlink\" title=\"1. 随机化基准\"></a>1. 随机化基准</h4><p>为避免在有序或近乎有序的数组上性能退化，可以随机选择一个元素作为基准。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 随机化分区</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">randomPartition</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 随机选择一个基准，并与最左侧元素交换</span></span><br><span class=\"line\">    <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> randomIndex = low + <span class=\"built_in\">rand</span>() % (high - low + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(arr[randomIndex], arr[low]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">partition</span>(arr, low, high);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-三数取中法\"><a href=\"#2-三数取中法\" class=\"headerlink\" title=\"2. 三数取中法\"></a>2. 三数取中法</h4><p>选择数组的左端、中间和右端三个元素的中位数作为基准，可以更有效地避免最坏情况。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三数取中获取基准并放到low位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">medianOfThree</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid = low + (high - low) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[mid] &lt; arr[low]) <span class=\"built_in\">swap</span>(arr[mid], arr[low]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[high] &lt; arr[low]) <span class=\"built_in\">swap</span>(arr[high], arr[low]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[mid] &lt; arr[high]) <span class=\"built_in\">swap</span>(arr[mid], arr[low]); <span class=\"comment\">// 将中值放到low</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSortWithMedian</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (low &lt; high) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">medianOfThree</span>(arr, low, high);</span><br><span class=\"line\">        <span class=\"type\">int</span> pivotIndex = <span class=\"built_in\">partition</span>(arr, low, high);</span><br><span class=\"line\">        <span class=\"built_in\">quickSortWithMedian</span>(arr, low, pivotIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">quickSortWithMedian</span>(arr, pivotIndex + <span class=\"number\">1</span>, high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"四、知识检验\"><a href=\"#四、知识检验\" class=\"headerlink\" title=\"四、知识检验\"></a>四、知识检验</h2><h3 id=\"4-1-测验题\"><a href=\"#4-1-测验题\" class=\"headerlink\" title=\"4.1 测验题\"></a>4.1 测验题</h3><ol>\n<li>快速排序的平均时间复杂度是多少？</li>\n<li>快速排序是稳定的排序算法吗？为什么？</li>\n<li>使用最左侧元素作为基准的快速排序在什么情况下会出现最坏性能？</li>\n<li>快速排序的空间复杂度是多少？它主要由什么产生？</li>\n</ol>\n<h3 id=\"4-2-测验答案\"><a href=\"#4-2-测验答案\" class=\"headerlink\" title=\"4.2 测验答案\"></a>4.2 测验答案</h3><ol>\n<li><strong>O(n log n)</strong>。</li>\n<li><strong>不是</strong>。因为在分区过程中，与基准相等的元素的相对位置可能会因为交换而改变。</li>\n<li>当数组<strong>已经排序</strong>或<strong>完全逆序</strong>时。此时每次分区都非常不平衡，导致递归树深度为 O(n)。</li>\n<li><strong>O(log n)</strong>。它主要由递归调用产生的函数调用栈空间所决定。最坏情况下空间复杂度会达到 O(n)。</li>\n</ol>\n<hr>\n<h2 id=\"五、练习与拓展\"><a href=\"#五、练习与拓展\" class=\"headerlink\" title=\"五、练习与拓展\"></a>五、练习与拓展</h2><h3 id=\"5-1-推荐练习题-LeetCode\"><a href=\"#5-1-推荐练习题-LeetCode\" class=\"headerlink\" title=\"5.1 推荐练习题 (LeetCode)\"></a>5.1 推荐练习题 (LeetCode)</h3><table>\n<thead>\n<tr>\n<th align=\"left\">推荐题目</th>\n<th align=\"left\">我的题解</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://leetcode.cn/problems/kth-largest-element-in-an-array/\">215. 数组中的第K个最大元素</a></td>\n<td align=\"left\">暂未完成</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode.cn/problems/sort-an-array/\">912. 排序数组</a></td>\n<td align=\"left\">暂未完成</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode.cn/problems/sort-colors/\">75. 颜色分类</a></td>\n<td align=\"left\">暂未完成</td>\n</tr>\n</tbody></table>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：虽然快速排序可以解决以上问题，但理解其核心的分区思想对于解决这类问题至关重要，不一定需要完整实现排序。</p></blockquote>\n<hr>\n<p><em>本文旨在帮助初学者理解快速排序的核心思想及应用，欢迎收藏和分享。</em></p>\n","text":"快速排序（Quick Sort）快速排序（Quick Sort）是一种极其高效的分治排序算法，也是实际应用中最常用的排序算法之一。它通过选择一个“基准”元素，将...","permalink":"/post/AlgorithmsDataStructures/排序算法/快速排序","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"算法与数据结构","slug":"算法与数据结构","count":3,"path":"api/categories/算法与数据结构.json"}],"tags":[{"name":"排序","slug":"排序","count":2,"path":"api/tags/排序.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89\"><span class=\"toc-text\">快速排序（Quick Sort）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">一、算法原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">1.1 核心思想</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">1.2 详细步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E7%A4%BA%E4%BE%8B%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">1.3 示例演示</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">二、性能与特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.1 复杂度分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">2.2 优缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2.3 适用场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">三、代码实现与优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%9F%BA%E7%A1%80%E7%89%88%E6%9C%AC-C\"><span class=\"toc-text\">3.1 基础版本 (C++)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5-C\"><span class=\"toc-text\">3.2 优化策略 (C++)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%9A%8F%E6%9C%BA%E5%8C%96%E5%9F%BA%E5%87%86\"><span class=\"toc-text\">1. 随机化基准</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E6%B3%95\"><span class=\"toc-text\">2. 三数取中法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C\"><span class=\"toc-text\">四、知识检验</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E6%B5%8B%E9%AA%8C%E9%A2%98\"><span class=\"toc-text\">4.1 测验题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E6%B5%8B%E9%AA%8C%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">4.2 测验答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">五、练习与拓展</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E6%8E%A8%E8%8D%90%E7%BB%83%E4%B9%A0%E9%A2%98-LeetCode\"><span class=\"toc-text\">5.1 推荐练习题 (LeetCode)</span></a></li></ol></li></ol></li></ol>","author":{"name":"Random","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"世界上本没有简单题，中等题刷过的人多了，就变成了简单题","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"冒泡排序（Bubble Sort）","uid":"dea48bae008655416810ebc549cb2ffd","slug":"AlgorithmsDataStructures/排序算法/冒泡排序","date":"2025-07-18T04:00:00.000Z","updated":"2025-07-28T13:31:45.257Z","comments":true,"path":"api/articles/AlgorithmsDataStructures/排序算法/冒泡排序.json","keywords":null,"cover":null,"text":"冒泡排序（Bubble Sort）冒泡排序是一种简单直观的排序算法。它重复地遍历待排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工...","permalink":"/post/AlgorithmsDataStructures/排序算法/冒泡排序","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"算法与数据结构","slug":"算法与数据结构","count":3,"path":"api/categories/算法与数据结构.json"}],"tags":[{"name":"排序","slug":"排序","count":2,"path":"api/tags/排序.json"}],"author":{"name":"Random","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"世界上本没有简单题，中等题刷过的人多了，就变成了简单题","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"LeetCode-2367等差三元组的数目","uid":"f01cc273b0b1b737816c95524ea0b79c","slug":"LeetCode/LeetCode-2367等差三元组的数目","date":"2025-07-17T08:00:00.000Z","updated":"2025-07-28T13:32:30.769Z","comments":true,"path":"api/articles/LeetCode/LeetCode-2367等差三元组的数目.json","keywords":null,"cover":null,"text":" 题目链接：LeetCode - 2367.Number of Arithmetic Triplets 解法一：三指针题目描述给定一个严格递增的整数数组 num...","permalink":"/post/LeetCode/LeetCode-2367等差三元组的数目","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","count":8,"path":"api/tags/LeetCode.json"}],"author":{"name":"Random","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"世界上本没有简单题，中等题刷过的人多了，就变成了简单题","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}