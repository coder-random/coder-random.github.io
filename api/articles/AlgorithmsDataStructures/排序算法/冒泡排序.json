{"title":"冒泡排序（Bubble Sort）","uid":"dea48bae008655416810ebc549cb2ffd","slug":"AlgorithmsDataStructures/排序算法/冒泡排序","date":"2025-07-18T04:00:00.000Z","updated":"2025-07-18T08:41:18.801Z","comments":true,"path":"api/articles/AlgorithmsDataStructures/排序算法/冒泡排序.json","keywords":null,"cover":null,"content":"<h1 id=\"冒泡排序（Bubble-Sort）\"><a href=\"#冒泡排序（Bubble-Sort）\" class=\"headerlink\" title=\"冒泡排序（Bubble Sort）\"></a>冒泡排序（Bubble Sort）</h1><p>冒泡排序是一种简单直观的排序算法。它重复地遍历待排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<hr>\n<h2 id=\"一、算法原理\"><a href=\"#一、算法原理\" class=\"headerlink\" title=\"一、算法原理\"></a>一、算法原理</h2><h3 id=\"1-1-核心思想\"><a href=\"#1-1-核心思想\" class=\"headerlink\" title=\"1.1 核心思想\"></a>1.1 核心思想</h3><p>冒泡排序的核心在于<strong>重复地比较并交换相邻元素</strong>。它会遍历整个数组，每次比较相邻的两个元素，如果它们的顺序不正确（例如，前者大于后者），就将它们交换。通过这样一轮轮的遍历，每一轮都会将当前未排序部分中的最大（或最小）元素“冒泡”到其最终位置。</p>\n<h3 id=\"1-2-详细步骤\"><a href=\"#1-2-详细步骤\" class=\"headerlink\" title=\"1.2 详细步骤\"></a>1.2 详细步骤</h3><ol>\n<li><strong>比较与交换</strong>：从数组的第一个元素开始，比较它与下一个元素的大小。如果顺序错误，则交换它们。</li>\n<li><strong>向后移动</strong>：将比较窗口向后移动一位，继续比较下一对相邻元素，重复此过程直到数组末尾。</li>\n<li><strong>完成一轮</strong>：当完成从头到尾的一轮遍历后，数组中最大的元素会被放置在最后一个位置。</li>\n<li><strong>缩小范围</strong>：忽略已经排好序的最后一个元素，对前面的 <code>n-1</code> 个元素重复以上步骤。</li>\n<li><strong>终止条件</strong>：持续这个过程，直到整个数组排序完成。</li>\n</ol>\n<h3 id=\"1-3-示例演示\"><a href=\"#1-3-示例演示\" class=\"headerlink\" title=\"1.3 示例演示\"></a>1.3 示例演示</h3><p>以数组 <code>[6, 4, 7, 2, 9]</code> 为例，排序过程如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">轮次</th>\n<th align=\"left\">过程描述</th>\n<th align=\"left\">数组状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">第1轮</td>\n<td align=\"left\"><code>6&gt;4</code>交换, <code>6&lt;7</code>不换, <code>7&gt;2</code>交换, <code>7&lt;9</code>不换</td>\n<td align=\"left\"><code>[4, 6, 2, 7, **9**]</code></td>\n</tr>\n<tr>\n<td align=\"left\">第2轮</td>\n<td align=\"left\"><code>4&lt;6</code>不换, <code>6&gt;2</code>交换, <code>6&lt;7</code>不换</td>\n<td align=\"left\"><code>[4, 2, 6, **7**, 9]</code></td>\n</tr>\n<tr>\n<td align=\"left\">第3轮</td>\n<td align=\"left\"><code>4&gt;2</code>交换, <code>4&lt;6</code>不换</td>\n<td align=\"left\"><code>[2, 4, **6**, 7, 9]</code></td>\n</tr>\n<tr>\n<td align=\"left\">第4轮</td>\n<td align=\"left\"><code>2&lt;4</code>不换</td>\n<td align=\"left\"><code>[**2**, 4, 6, 7, 9]</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"二、性能与特点\"><a href=\"#二、性能与特点\" class=\"headerlink\" title=\"二、性能与特点\"></a>二、性能与特点</h2><h3 id=\"2-1-复杂度分析\"><a href=\"#2-1-复杂度分析\" class=\"headerlink\" title=\"2.1 复杂度分析\"></a>2.1 复杂度分析</h3><ul>\n<li><strong>时间复杂度</strong><ul>\n<li>最佳情况：O(n) - 当数组几乎有序时，优化后的算法只需一轮遍历。</li>\n<li>平均情况：O(n²)</li>\n<li>最坏情况：O(n²) - 当数组完全逆序时。</li>\n</ul>\n</li>\n<li><strong>空间复杂度</strong>：O(1) - 属于原地排序，仅需常数级别的额外空间。</li>\n<li><strong>稳定性</strong>：<strong>稳定</strong>。因为只有当前元素严格大于后一个元素时才交换，相等元素的相对顺序不会改变。</li>\n</ul>\n<h3 id=\"2-2-优缺点\"><a href=\"#2-2-优缺点\" class=\"headerlink\" title=\"2.2 优缺点\"></a>2.2 优缺点</h3><table>\n<thead>\n<tr>\n<th align=\"left\">优点</th>\n<th align=\"left\">缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>实现简单</strong>，代码易于理解</td>\n<td align=\"left\"><strong>效率低下</strong>，不适合大规模数据</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>稳定性好</strong>，保留相等元素顺序</td>\n<td align=\"left\">比较和交换次数过多</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>空间占用少</strong>，是原地排序算法</td>\n<td align=\"left\">性能远不如快速排序、归并排序等</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-适用场景\"><a href=\"#2-3-适用场景\" class=\"headerlink\" title=\"2.3 适用场景\"></a>2.3 适用场景</h3><ul>\n<li><strong>教学演示</strong>：作为入门级排序算法，非常适合教学。</li>\n<li><strong>小规模数据</strong>：当待排序的元素数量很少时（例如 n &lt; 20），其简单性可能优于复杂算法的设置开销。</li>\n<li><strong>几乎有序的数组</strong>：优化后的冒泡排序在这种情况下效率很高。</li>\n</ul>\n<hr>\n<h2 id=\"三、代码实现与优化\"><a href=\"#三、代码实现与优化\" class=\"headerlink\" title=\"三、代码实现与优化\"></a>三、代码实现与优化</h2><p><em>(以下代码默认 <code>using namespace std;</code>)</em></p>\n<h3 id=\"3-1-基础版本-C\"><a href=\"#3-1-基础版本-C\" class=\"headerlink\" title=\"3.1 基础版本 (C++)\"></a>3.1 基础版本 (C++)</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基础冒泡排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每轮将一个最大值放到末尾</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(arr[j], arr[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-优化版本-C\"><a href=\"#3-2-优化版本-C\" class=\"headerlink\" title=\"3.2 优化版本 (C++)\"></a>3.2 优化版本 (C++)</h3><p>通过增加一个标志位，可以检测数组是否已经提前有序，从而避免不必要的遍历。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优化版冒泡排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">optimizedBubbleSort</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> swapped = <span class=\"literal\">false</span>; <span class=\"comment\">// 交换标志位</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(arr[j], arr[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                swapped = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果在一轮遍历中没有发生交换，说明数组已有序</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!swapped) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-拓展：鸡尾酒排序\"><a href=\"#3-3-拓展：鸡尾酒排序\" class=\"headerlink\" title=\"3.3 拓展：鸡尾酒排序\"></a>3.3 拓展：鸡尾酒排序</h3><p>鸡尾酒排序（Cocktail Shaker Sort）是冒泡排序的变体，它通过双向遍历来提升性能，既从左到右“冒泡”最大值，也从右到左“冒泡”最小值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 鸡尾酒排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cocktailSort</span><span class=\"params\">(<span class=\"type\">int</span> arr[], <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> swapped = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> end = n - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (swapped) &#123;</span><br><span class=\"line\">        swapped = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从左到右，将最大值移动到末尾</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = start; i &lt; end; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &gt; arr[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(arr[i], arr[i + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                swapped = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!swapped) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        --end;</span><br><span class=\"line\"></span><br><span class=\"line\">        swapped = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从右到左，将最小值移动到开头</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = end - <span class=\"number\">1</span>; i &gt;= start; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &gt; arr[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(arr[i], arr[i + <span class=\"number\">1</span>]);</span><br><span class=\"line\">                swapped = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++start;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"四、知识检验\"><a href=\"#四、知识检验\" class=\"headerlink\" title=\"四、知识检验\"></a>四、知识检验</h2><h3 id=\"4-1-测验题\"><a href=\"#4-1-测验题\" class=\"headerlink\" title=\"4.1 测验题\"></a>4.1 测验题</h3><ol>\n<li>冒泡排序的平均时间复杂度是多少？</li>\n<li>为什么说冒泡排序是稳定的？</li>\n<li>对于一个已经完全排好序的数组，优化版的冒泡排序时间复杂度是多少？</li>\n<li>冒泡排序每一轮遍历结束后，能确定哪个元素的位置？</li>\n<li>除了设置标志位提前终止，还有其他优化冒泡排序的思路吗？</li>\n</ol>\n<h3 id=\"4-2-测验答案\"><a href=\"#4-2-测验答案\" class=\"headerlink\" title=\"4.2 测验答案\"></a>4.2 测验答案</h3><ol>\n<li>平均时间复杂度是 <strong>O(n²)</strong>。</li>\n<li>因为只有当前一个元素严格大于后一个元素时才进行交换，相等元素之间的相对顺序不会改变。</li>\n<li>时间复杂度为 <strong>O(n)</strong>，因为它只需要完整遍历一次，发现没有发生任何元素交换后就会提前退出。</li>\n<li>每一轮结束后，都能确定<strong>当前未排序部分的最大元素</strong>的位置，并将其置于该部分的末尾。</li>\n<li>可以记录<strong>最后一次发生交换的位置</strong>，下一轮遍历时只需扫描到该位置即可，因为之后的部分已经是有序的了。</li>\n</ol>\n<hr>\n<h2 id=\"五、练习与拓展\"><a href=\"#五、练习与拓展\" class=\"headerlink\" title=\"五、练习与拓展\"></a>五、练习与拓展</h2><h3 id=\"5-1-推荐练习题-LeetCode\"><a href=\"#5-1-推荐练习题-LeetCode\" class=\"headerlink\" title=\"5.1 推荐练习题 (LeetCode)\"></a>5.1 推荐练习题 (LeetCode)</h3><table>\n<thead>\n<tr>\n<th align=\"left\">推荐题目</th>\n<th align=\"left\">我的题解</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://leetcode.cn/problems/sort-colors/\">75. 颜色分类</a></td>\n<td align=\"left\">暂未完成</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode.cn/problems/move-zeroes/\">283. 移动零</a></td>\n<td align=\"left\">暂未完成</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://leetcode.cn/problems/sort-an-array/\">912. 排序数组</a></td>\n<td align=\"left\">暂未完成</td>\n</tr>\n</tbody></table>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：虽然冒泡排序可以解决以上问题，但通常不是时间复杂度最优的解法，这些题目更适合用于加深对排序思想的理解。</p></blockquote>\n<hr>\n<p><em>本文旨在帮助初学者理解冒泡排序的核心思想及应用，欢迎收藏和分享。</em></p>\n","text":"冒泡排序（Bubble Sort）冒泡排序是一种简单直观的排序算法。它重复地遍历待排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工...","permalink":"/post/AlgorithmsDataStructures/排序算法/冒泡排序","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"算法与数据结构","slug":"算法与数据结构","count":3,"path":"api/categories/算法与数据结构.json"},{"name":"排序算法","slug":"算法与数据结构/排序算法","count":2,"path":"api/categories/算法与数据结构/排序算法.json"}],"tags":[{"name":"排序","slug":"排序","count":2,"path":"api/tags/排序.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89\"><span class=\"toc-text\">冒泡排序（Bubble Sort）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">一、算法原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">1.1 核心思想</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">1.2 详细步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E7%A4%BA%E4%BE%8B%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">1.3 示例演示</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">二、性能与特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.1 复杂度分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">2.2 优缺点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2.3 适用场景</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">三、代码实现与优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%9F%BA%E7%A1%80%E7%89%88%E6%9C%AC-C\"><span class=\"toc-text\">3.1 基础版本 (C++)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC-C\"><span class=\"toc-text\">3.2 优化版本 (C++)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E6%8B%93%E5%B1%95%EF%BC%9A%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">3.3 拓展：鸡尾酒排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E7%9F%A5%E8%AF%86%E6%A3%80%E9%AA%8C\"><span class=\"toc-text\">四、知识检验</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E6%B5%8B%E9%AA%8C%E9%A2%98\"><span class=\"toc-text\">4.1 测验题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E6%B5%8B%E9%AA%8C%E7%AD%94%E6%A1%88\"><span class=\"toc-text\">4.2 测验答案</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">五、练习与拓展</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E6%8E%A8%E8%8D%90%E7%BB%83%E4%B9%A0%E9%A2%98-LeetCode\"><span class=\"toc-text\">5.1 推荐练习题 (LeetCode)</span></a></li></ol></li></ol></li></ol>","author":{"name":"Random","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"世界上本没有简单题，中等题刷过的人多了，就变成了简单题","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"LeetCode-912排序数组","uid":"94d081a5c7789012b1a36e6503ab4408","slug":"LeetCode/LeetCode-912排序数组","date":"2025-07-18T08:00:00.000Z","updated":"2025-07-18T09:10:10.642Z","comments":true,"path":"api/articles/LeetCode/LeetCode-912排序数组.json","keywords":null,"cover":null,"text":" LeetCode - 912. 排序数组 题目描述：给你一个整数数组 nums，请你将该数组升序排列。你必须在 不使用任何内置函数 的情况下解决问题，时间复杂...","permalink":"/post/LeetCode/LeetCode-912排序数组","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","count":8,"path":"api/tags/LeetCode.json"}],"author":{"name":"Random","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"世界上本没有简单题，中等题刷过的人多了，就变成了简单题","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"快速排序（Quick Sort）","uid":"128d5f401a6627e4435b6e43e76ac072","slug":"AlgorithmsDataStructures/排序算法/快速排序","date":"2025-07-18T04:00:00.000Z","updated":"2025-07-18T08:50:49.902Z","comments":true,"path":"api/articles/AlgorithmsDataStructures/排序算法/快速排序.json","keywords":null,"cover":null,"text":"快速排序（Quick Sort）快速排序（Quick Sort）是一种极其高效的分治排序算法，也是实际应用中最常用的排序算法之一。它通过选择一个“基准”元素，将...","permalink":"/post/AlgorithmsDataStructures/排序算法/快速排序","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"算法与数据结构","slug":"算法与数据结构","count":3,"path":"api/categories/算法与数据结构.json"},{"name":"排序算法","slug":"算法与数据结构/排序算法","count":2,"path":"api/categories/算法与数据结构/排序算法.json"}],"tags":[{"name":"排序","slug":"排序","count":2,"path":"api/tags/排序.json"}],"author":{"name":"Random","slug":"blog-author","avatar":"/images/avatar.png","link":"/","description":"世界上本没有简单题，中等题刷过的人多了，就变成了简单题","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}